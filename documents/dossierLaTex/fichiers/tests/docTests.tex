\begin{enum}
    \item interpreteurlir.tests.TestContexte
\begin{verbatim}
/**
 * TestContexte.java                              8 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.donnees.*;
import interpreteurlir.donnees.litteraux.*;

/**
 * Tests unitaires de {@link Contexte}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestContexte {

    /** Jeux de tests de Contexte */
    private Contexte[] fixture = { 
            new Contexte(), new Contexte(), new Contexte(),
    };
    
    /**
     * Tests unitaires de {@link Contexte#Contexte()}
     */
    public void testContexte() {
        System.out.println("\tExécution du test de Contexte#Contexte()");
        try {
            new Contexte();  
        } catch (Exception e) {
            echec();
        }
    }
    
    /**
     * Tests unitaires de 
     * {@link Contexte#ajouterVariable(Identificateur, Litteral)}
     */
    public void testAjouterVariable() {
        Identificateur[] id = {
                new IdentificateurChaine("$chaine"), // ajout dans liste vide
                new IdentificateurEntier("entier"), // ajout fin
                new IdentificateurChaine("$zoro"),  // ajout milieu
                // modif variable présente
                new IdentificateurChaine("$chaine"), // ajout dans liste vide
                new IdentificateurEntier("entier"), // ajout fin
                new IdentificateurChaine("$zoro"),  // ajout milieu
                
                new IdentificateurChaine("$abcd"),  // ajout debut
        };
        
        Litteral[] valeur = {
                new Chaine("\"blabla\""),
                new Entier(25),
                new Chaine("\"Zoro le héro\""),
                
                new Chaine("\"viveLa Vie\""),
                new Entier(-1),
                new Chaine("\"   ah ah !  \""),
                
                new Chaine("\"lol\""),
        };
        
        System.out.println("\tExécution du test de "
                + "Contexte#ajouterVariable(Identificateur, Litteral)");
        
        for (int numAjout = 0 ; numAjout < id.length ; numAjout++) {
            fixture[0].ajouterVariable(id[numAjout], valeur[numAjout]);
            if (numAjout == 2) {
                System.out.println(fixture[0].toString());
            }
        }
        System.out.println(fixture[0].toString());
    }
    
    /**
     * Tests unitaires de {@link Contexte#toString()}
     */
    public void testToString() {
        String[] chaineAttendue = {
                "aucune variable n'est définie\n",
                "aucune variable n'est définie\n",
                "aucune variable n'est définie\n",
        };
        
        System.out.println("\tExécution du test de Contexte#toString()");
        for (int numTest = 0 ; numTest < chaineAttendue.length ; numTest++) {
            assertEquivalence(fixture[numTest].toString(),
                              chaineAttendue[numTest]);
        }
    }
    
    /**
     * Tests unitaires de {@link Contexte#raz()}
     */
    public void testRaz() {
        String toStringVide = "aucune variable n'est définie\n";
        
        // fixture 0 est vide
        
        // fixture 1 a 3 éléments à vider
        fixture[1].ajouterVariable(new IdentificateurChaine("$chaine"), 
                                   new Chaine("\"blabla\""));
        fixture[1].ajouterVariable(new IdentificateurEntier("entier"), 
                                   new Entier(25));
        fixture[1].ajouterVariable(new IdentificateurChaine("$zoro"), 
                                   new Chaine("\"Zoro le héro\""));
        
        // fixture 2 a 1 éléments unique
        fixture[1].ajouterVariable(new IdentificateurChaine("$zer"), 
                                   new Chaine("\"blvzgr\""));
        
        System.out.println("\tExécution du test de Contexte#raz()");
        for (Contexte aTester : fixture) {
            aTester.raz();
            // toString doit être celui d'un contexte vide
            assertEquivalence(toStringVide, aTester.toString());
        }
    }
    
    /**
     * Tests unitaire de {@link Contexte#lireValeurVariable(Identificateur)}
     */
    public void testLireValeurVariable() {

        System.out.println("\tExécution du test de "
                           + "Contexte#lireValeurVariable(Identificateur)");
        
        // lire valeur défaut contexte vid
        assertEquivalence(fixture[0].lireValeurVariable(
                new IdentificateurChaine("$chaine")).getValeur(), "");
        assertEquivalence(fixture[0].lireValeurVariable(
                new IdentificateurEntier("entier")).getValeur(), 
                                         Integer.valueOf(0));
        
        // lire valeur par défaut dans contexte non vide
        fixture[1].ajouterVariable(new IdentificateurChaine("$zoro"), 
                new Chaine("\"Zoro le héro\""));
        
        assertEquivalence(fixture[1].lireValeurVariable(
                new IdentificateurChaine("$chaine")).getValeur(), "");
        assertEquivalence(fixture[1].lireValeurVariable(
                new IdentificateurEntier("entier")).getValeur(), 0);
        
        // lire valeur qui existent déjà
        fixture[1].ajouterVariable(new IdentificateurChaine("$chaine"), 
                                   new Chaine("\"blabla\""));
        fixture[1].ajouterVariable(new IdentificateurEntier("entier"), 
                                   new Entier(25));
        
        System.out.println(fixture[1].lireValeurVariable(
                new IdentificateurChaine("$zoro")).getValeur());
        
        
        assertEquivalence(fixture[1].lireValeurVariable(
                new IdentificateurChaine("$chaine")).getValeur(), "blabla");
        assertEquivalence(fixture[1].lireValeurVariable(
                          new IdentificateurEntier("entier")).getValeur(), 25);
        assertEquivalence(fixture[1].lireValeurVariable(
                              new IdentificateurChaine("$zoro")).getValeur(), 
                          "Zoro le héro");

        
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de Contexte#Contexte()
Réussite de testContexte
    Exécution du test de Contexte#raz()
Réussite de testRaz
    Exécution du test de Contexte#toString()
Réussite de testToString
    Exécution du test de Contexte#ajouterVariable(Identificateur, Litteral)
$chaine = "blabla"
$zoro = "Zoro le héro"
entier = 25

$abcd = "lol"
$chaine = "viveLa Vie"
$zoro = "   ah ah !  "
entier = -1

Réussite de testAjouterVariable
    Exécution du test de Contexte#lireValeurVariable(Identificateur)
Zoro le héro
Réussite de testLireValeurVariable
\end{verbatim}

    \item interpreteurlir.donnees.tests.TestIdentificateurChaine
\begin{verbatim}
/*
 * TestIdentificateurChaine.java, 08/05/2021
 * IUT Rodez 2020-2021, info1
 * pas de copyright, aucun droits
 */

package interpreteurlir.donnees.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurChaine;

/**
 * Tests unitaires de la classe donnees.IdentificateurEntier
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestIdentificateurChaine {
    /** Jeu d'identificateurs de chaîne correctement instanciés */
    private static IdentificateurChaine[] FIXTURE = {
            new IdentificateurChaine("$a"),
            new IdentificateurChaine("$A"),
            new IdentificateurChaine("$alpha"),
            new IdentificateurChaine("$Alpha"),
            new IdentificateurChaine("$Alpha5"),
            new IdentificateurChaine("$jeSuisUnTresLongIdentifi")
    };

    /**
     * Tests unitaires du constructeur 
     * IdentificateurEntier(String identificateur)
     */
    public static void testIdentificateurChaineString() {
        final String[] INVALIDE = {
                "",

                // Commence par une lettre
                "9alpha",
                "  5alpha",

                // Fait au maximum 25 caractères
                "$jeSuisUnTresLongIdentificateur", // 30 char
                "$jeSuisUnTresLongIdentifica",

                // Espaces
                "id 3a",
                "$id 3a",
                " ",
                "$ ",

                // caractères d'échapements
                "\t",
                "\n",
                "$\t",
                "$\n",

                // , cas particulier
                "$",
                "$1"
        };
        System.out.println("\tExécution du test de "
                           + "IdentificateurEntier(String identificateur)");
        for(int noJeu = 0; noJeu < INVALIDE.length ; noJeu++) {
            try {
                new IdentificateurChaine(INVALIDE[noJeu]);
                echec();
            } catch (InterpreteurException lancee) {
                // test OK
            }
        }
        
    }

    /**
     * Tests unitaires de getNom()
     */
    public static void testGetNom() {
        final String[] NOM_VALIDES = {
                "$a",
                "$A",
                "$alpha",
                "$Alpha",
                "$Alpha5",
                "$jeSuisUnTresLongIdentifi"
        };

        System.out.println("\tExécution du test de getNom()");
        for (int noJeu = 0 ; noJeu < NOM_VALIDES.length ; noJeu++) {
            assertEquivalence(NOM_VALIDES[noJeu], FIXTURE[noJeu].getNom());
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de IdentificateurEntier(String identificateur)
Réussite de testIdentificateurChaineString
    Exécution du test de getNom()
Réussite de testGetNom
\end{verbatim}

    \item interpreteurlir.donnees.tests.TestIdentificateurEntier
\begin{verbatim}
/*
 * TestIdentificateurEntier.java , 08/05/2021
 * IUT Rodez 2020-2021, info1
 * pas de copyright, aucun droits
 */

package interpreteurlir.donnees.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurEntier;

/**
 * Tests unitaires de la classe donnees.IdentificateurEntier
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestIdentificateurEntier {

    /** Jeu d'identificateurs d'entier correctement instanciés */
    private static IdentificateurEntier[] FIXTURE = {
            new IdentificateurEntier("a"),
            new IdentificateurEntier("A"),
            new IdentificateurEntier("alpha"),
            new IdentificateurEntier("Alpha"),
            new IdentificateurEntier("Alpha5"),
            new IdentificateurEntier("jeSuisUnTresLongIdentific")
    };

    /**
     * Tests unitaires du constructeur IdentificateurEntier(String identificateur)
     */
    public static void testIdentificateurEntierString() {
        final String[] INVALIDE = {
                // Ne commence pas  par une lettre
                "9alpha",
                "  5alpha",
                "$beta",

                // Fait plus de 25 caractères
                "jeSuisUnTresLongIdentificateur", // 30 char
                "jeSuisUnTresLongIdentifica",

                // Espaces, caractères d'échapements, cas particulier
                "id 3a",
                "",
                " ",
                "\t",
                "\n",
        };

        for(int noJeu = 0; noJeu < INVALIDE.length ; noJeu++) {
            try {
                new IdentificateurEntier(INVALIDE[noJeu]);
                echec();
            } catch (InterpreteurException lancee) {
                // test OK
            }
        }
    }

    /**
     * Tests unitaires de getNom()
     */
    public static void testGetNom() {
        final String[] NOM_VALIDES = {
                "a",
                "A",
                "alpha",
                "Alpha",
                "Alpha5",
                "jeSuisUnTresLongIdentific"
        };

        for (int noJeu = 0 ; noJeu < NOM_VALIDES.length ; noJeu++) {
            assertEquivalence(NOM_VALIDES[noJeu], FIXTURE[noJeu].getNom());
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
Réussite de testIdentificateurEntierString
Réussite de testGetNom
\end{verbatim}


    \item interpreteurlir.donnees.tests.TestVariable
\begin{verbatim}
/**
 * TestVariable.java                                        8 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.donnees.tests;

import interpreteurlir.donnees.Variable;
import interpreteurlir.donnees.IdentificateurChaine;
import interpreteurlir.donnees.IdentificateurEntier;
import interpreteurlir.donnees.litteraux.*;
import interpreteurlir.InterpreteurException;

import static info1.outils.glg.Assertions.*;

/** 
 * Tests unitaires de la classe Variable
 *  
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucàs Vabre
 */
public class TestVariable {
    
    /** Jeu d'identificateurs de chaîne valides */
    private static final IdentificateurChaine[] ID_CHAINE = {
        new IdentificateurChaine("$a"),
        new IdentificateurChaine("$B"),
        new IdentificateurChaine("$alpha"),
        new IdentificateurChaine("$Alpha"),
        new IdentificateurChaine("$Alpha5"),
        new IdentificateurChaine("$jeSuisUnTresLongIdentifi"),
        new IdentificateurChaine("$R2D2"),
        new IdentificateurChaine("$MichelSardou"),
        new IdentificateurChaine("$PhilippePoutou2022")
    };

    /** Jeu d'identificateurs d'entier valides */
    private static final IdentificateurEntier[] ID_ENTIER = {
        new IdentificateurEntier("a"),
        new IdentificateurEntier("A"),
        new IdentificateurEntier("alpha"),
        new IdentificateurEntier("Alpha"),
        new IdentificateurEntier("Alpha5"),
        new IdentificateurEntier("jeSuisUnTresLongIdentifi"),
        new IdentificateurEntier("R2D2"),
        new IdentificateurEntier("MichelSardou"),
        new IdentificateurEntier("PhilippePoutou2022")
    };
    
    /** Jeu de chaînes valides */
    private static final Chaine[] VALEURS_CHAINE = {
        new Chaine(),
        new Chaine("\"arztyehjklmpoijhghnbghjklmpoiuytrf" 
                   + "ghjnklmpoiuytrezaqsdfghnjklmpjbfrtyu\""), 
        new Chaine("\"\""),
        new Chaine("\"coucou \""),
        new Chaine("\"" + Integer.toString(42) + "\""),
        new Chaine("\"Bidon\""),
        new Chaine("\"toto\""),
        new Chaine("\"tata\t\""),
        new Chaine("\"titi\n\"")
    };
    
    /** Jeu de variables chaîne valides*/
    private static Variable[] fixtureChaine = new Variable[ID_CHAINE.length];   
    
    private static void fixtureReload() {
        for (int i = 0; i < ID_CHAINE.length; i++) {
            fixtureChaine[i] = new Variable(ID_CHAINE[i], VALEURS_CHAINE[i]); 
        }
    }
    
    /** 
     * Test unitaire du constructeur Variable(Identificateur, Littéral)
     */
    public static void testVariableIdentificateurChaineLitteral() {
        System.out.println("\tExécution du test de "
                           + "Variable(Identificateur, Littéral)");
        for (int noJeu = 0; noJeu < VALEURS_CHAINE.length; noJeu++) {
            try {
                new Variable(ID_ENTIER[noJeu], VALEURS_CHAINE[noJeu]);
                echec();
            } catch (InterpreteurException lancee) {
                // test OK
            }
        }
    }
    
    /** 
     * Test unitaire de getIdentificateur() d'une variable chaîne
     */
    public static void testGetIdentificateurChaine() {
        fixtureReload();
        
        System.out.println("\tExécution du test de getIdentificateur()");
        
        for (int i = 0; i < VALEURS_CHAINE.length; i++ ) {
            assertTrue(ID_CHAINE[i].compareTo(fixtureChaine[i]
                                              .getIdentificateur()) == 0);
        }
    }
    
    /** 
     * Test unitaire de getValeur() d'une variable chaîne
     */
    public static void testGetValeurChaine() {
        fixtureReload();
        
        System.out.println("\tExécution du test de getValeur()");
        for (int i = 0; i < VALEURS_CHAINE.length; i++ ) {
            assertTrue(VALEURS_CHAINE[i]
                           .compareTo(fixtureChaine[i].getValeur()) == 0);
        }
    }
    
    /** 
     * Test unitaire de setValeur() d'une chaîne
     */
    public static void testSetValeurChaine() {
        
        fixtureReload();
        
        final Chaine[] NOUVELLE_CHAINE = {
                new Chaine("\"titi\""),
                new Chaine("\"Mathématiques\""),
                new Chaine("\"!?9563Message\""),
                new Chaine("\"test TESTS\""),
                new Chaine("\"-5 + 962\"")
        };
        
        System.out.println("\tExécution du test de setValeur()");
        for (int i = 0; i < NOUVELLE_CHAINE.length; i++) {
            fixtureChaine[i].setValeur(NOUVELLE_CHAINE[i]);
            assertTrue(NOUVELLE_CHAINE[i]
                       .compareTo(fixtureChaine[i].getValeur()) == 0);
        }
    }
    
    /** 
     * Test unitaire de toString()
     */
    public static void testToString() {
        fixtureReload();
        
        final String[] ATTENDUS = {
                "$a = \"\"",
                "$B = \"arztyehjklmpoijhghnbghjklmpoiuytrf" 
                + "ghjnklmpoiuytrezaqsdfghnjklmpjbfrtyu\"",
                "$alpha = \"\"",
                "$Alpha = \"coucou \"",
                "$Alpha5 = \"42\"",
                "$jeSuisUnTresLongIdentifi = \"Bidon\"",
                "$R2D2 = \"toto\"",
                "$MichelSardou = \"tata\t\"",
                "$PhilippePoutou2022 = \"titi\n\""
        };
        System.out.println("\tExécution du test de toString()");        
        for (int noJeu = 0; noJeu < fixtureChaine.length; noJeu++ ) {
            assertEquivalence(fixtureChaine[noJeu].toString(), 
                              ATTENDUS[noJeu]);
        }
    }
    
    /** 
     * Test unitaire de compareTo()
     */
    public static void testCompareTo() {
        fixtureReload();
        
        final Variable REF_MIN
        = new Variable(new IdentificateurChaine("$A"),
                       new Chaine("\"Min\""));
        
        final Variable REF_MAX
        = new Variable(new IdentificateurChaine("$z"),
                       new Chaine("\"Max\""));

        System.out.println("\tExécution du test de compareTo");
        for(int noJeu = 0;  noJeu < fixtureChaine.length; noJeu++) {
            assertTrue(fixtureChaine[noJeu].compareTo(REF_MIN) > 0);
            assertTrue(fixtureChaine[noJeu].compareTo(REF_MAX) < 0);
            assertTrue(fixtureChaine[noJeu].compareTo(fixtureChaine[noJeu]) == 0);
        }
        
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de toString()
Réussite de testToString
    Exécution du test de compareTo
Réussite de testCompareTo
    Exécution du test de Variable(Identificateur, Littéral)
Réussite de testVariableIdentificateurChaineLitteral
    Exécution du test de getIdentificateur()
Réussite de testGetIdentificateurChaine
    Exécution du test de getValeur()
Réussite de testGetValeurChaine
    Exécution du test de setValeur()
Réussite de testSetValeurChaine
\end{verbatim}

    \item interpreteurlir.donnees.litteraux.tests.TestBooleen
\begin{verbatim}
/**
 * TestBooleen.java                              21 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.donnees.litteraux.tests;

import interpreteurlir.donnees.litteraux.Booleen;
import static info1.outils.glg.Assertions.*;

/** 
 * Tests unitaires des méthodes de la classe Booleen
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestBooleen {
    
    private static final Booleen[] FIXTURE = {
        new Booleen(false),
        new Booleen(true),
        new Booleen(1<2),
        new Booleen(1>=2),
        new Booleen("bob".equals("bob")),
        new Booleen(Character.isDigit('a')),
        new Booleen(!Double.isNaN(1/0.0)),
    };
    
    /** 
     * Tests unitaire de {@link Booleen#getValeur()}
     */
    public void testGetValeur() {
        final Boolean[] ATTENDUS = {
            false,
            true,
            true,
            false,
            true,
            false,
            true
        };
        System.out.println("\tExécution du test de getValeur");
        for (int i = 0 ; i < ATTENDUS.length ; i++) {
            assertTrue(ATTENDUS[i].compareTo(FIXTURE[i].getValeur())
                       == 0);
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de getValeur
Réussite de testGetValeur
\end{verbatim}

    \item interpreteurlir.donnees.litteraux.tests.TestChaine
\begin{verbatim}
/**
 * TestChaine.java                                    8 mai 2021
 * IUT info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.donnees.litteraux.tests;

import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.litteraux.Chaine;

import static info1.outils.glg.Assertions.*;

/**  
 * Tests unitaires de la classe Chaine
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestChaine {


    /** Test unitaire de {@link Chaine#Chaine(String)} */
    public static void testChaine() {

        final String[] VALIDE = { 
                "\"arztyehjklmpoijhghnbghjklmpoiuytrf" + 
                        "ghjnklmpoiuytrezaqsdfghnjklmpjbfrtyu\"", 
                "\"\"",
                "\"coucou \"",
                "\"" + 42 + "\""
        };  

        final String INVALIDE =
                "arztyehjklmpoijhghnbghjklmpoiuytrf" + 
                        "yeryghjnklmpoiuytrezaqsdfghnjklmpjbfrtyu";

        System.out.println("\tExécution du test de Chaine(String)");

        for(String aTester : VALIDE) {
            try {
                new Chaine(aTester);
            } catch (InterpreteurException lancee) {
                echec();
            }
        }

        try {
            new Chaine(INVALIDE);
            echec();
        } catch (InterpreteurException lancee) {
            // Test OK
        }
    }

    /** Test unitaire de {@link Chaine#compareTo(Litteral)} */
    public static void testCompareTo() {
        final Chaine[][] EGALITES = { 
                { new Chaine("\"coucou\""), new Chaine("\"coucou\"") }, 
                { new Chaine("\" \""), new Chaine("\" \"") },
                { new Chaine("\"\""), new Chaine() } 
        };

        final Chaine[][] DIFFERENCES = { 
                { new Chaine("\"coucou\""), new Chaine("\"camomille\"") },
                { new Chaine("\"tarentule\""), new Chaine("\"coucou\"") }, 
                { new Chaine("\"coucou\""), new Chaine("\" \"") }, 
                { new Chaine("\"coucou\""), new Chaine() },
                { new Chaine("\" \""), new Chaine() } 
        };

        System.out.println("\tExécution du test de compareTo(Chaine)\n"
                            + "\tAvec égalités");

        for (Chaine[] couple : EGALITES) {
            assertEquivalence(couple[0].compareTo(couple[1]), 0);
        }

        System.out.println("\tAvec des inégalités");
        for (Chaine[] couple : DIFFERENCES) {
            assertTrue(couple[0].compareTo(couple[1]) > 0);
        }
    }

    /** Test unitaire de {@link Chaine#toString()} */
    public static void testToString() {
        final Chaine[] A_AFFICHER = {
                new Chaine(), 
                new Chaine("\" \""), 
                new Chaine("\"coucou\""),
                new Chaine("\" coucou \""), 
                new Chaine("\"coucou monsieur\"")
        };

        final String[] AFFICHAGE_GUILLEMETS = {
                "\"\"", 
                "\" \"", 
                "\"coucou\"", 
                "\" coucou \"",
                "\"coucou monsieur\""
        };

        System.out.println("\tExécution du test de toString");
        for (int i = 0 ; i < A_AFFICHER.length ; i++) {
            assertTrue(AFFICHAGE_GUILLEMETS[i]
                        .equals(A_AFFICHER[i].toString()));
        }
    }

    /**
     * Tests unitaires de concaténer
     */
    public static void testConcatener() {
        final Chaine[] ATTENDU = {
                new Chaine(),
                new Chaine("\"Bonjour le monde ! \""),
                new Chaine("\" \""),
                new Chaine("\"3,1415\""),
        };

        final Chaine[][] A_CONCATENER = {
                { new Chaine(), new Chaine("\"\"") },   
                { new Chaine("\"Bonjour \""), new Chaine("\"le monde ! \"") },
                { new Chaine("\"\""), new Chaine("\" \"") },
                { new Chaine("\"3,\""), new Chaine("\"1415\"") },
        };

        System.out.println("\tExécution du test de concaténer");
        for (int numTest = 0 ; numTest < ATTENDU.length ; numTest++ ) {
            assertTrue(ATTENDU[numTest].compareTo(
                           Chaine.concatener(A_CONCATENER[numTest][0], 
                                   A_CONCATENER[numTest][1])) == 0);
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de Chaine(String)
Réussite de testChaine
    Exécution du test de toString
Réussite de testToString
    Exécution du test de compareTo(Chaine)
    Avec égalités
    Avec des inégalités
Réussite de testCompareTo
    Exécution du test de concaténer
Réussite de testConcatener
\end{verbatim}

    \item interpreteurlir.donnees.litteraux.tests.TestEntier
\begin{verbatim}
/**
 * TestEntier.java                                        13 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.donnees.litteraux.tests;

import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.litteraux.Entier;

import static interpreteurlir.donnees.litteraux.Entier.*;
import static info1.outils.glg.Assertions.*;

import static java.lang.Integer.MIN_VALUE;
import static java.lang.Integer.MAX_VALUE;

/** 
 * Tests des méthode de la classe Entier
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestEntier {

    /** Jeu d'entiers correctement instanciés à partir d'un entier */
    private final Entier[] ENTIERS_INT = {
        new Entier(MIN_VALUE),
        new Entier(MAX_VALUE),
        new Entier(1),
        new Entier(-4587),
        new Entier(-569),
        new Entier(-3),
        new Entier(0),
        new Entier(2),
        new Entier(78),
        new Entier(781),
        new Entier(179892),
    };
    
    /** Jeu d'integers correspondants */
    private static final int[] INT_VALIDES = {
        MIN_VALUE,
        MAX_VALUE,
        1,
        -4587,
        -569,
        -3,
        0,
        2,
        78,
        781,
        179892,
    };

    /**
     * Test unitaire du constructeur Entier(String)
     */
    public static void testEntierString() {
        final String[] INVALIDES = {
                null,
                "",
                "          ",
                "\t",
                "\n",
                "a",
                "michel",
                "Janis Joplin",
                "(93)",
                "      78.3",
                "2147483648756",
                "2147483648",
                "+2147483648",
                "-2147483649",
                "-",
                "+",
        };
        
        System.out.println("\tExécution du test de Entier(String)");
        for (int i = 0; i < INVALIDES.length; i++) {
            try {
                new Entier(INVALIDES[i]);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
    }
    
    /** 
     * Test unitaire de la méthode toString()
     */
    public void testToString() {
        System.out.println("\tExécution du test de Entier(String)");
        for (int i = 0; i < INT_VALIDES.length; i ++) {
            assertTrue(ENTIERS_INT[i].toString()
                       .compareTo(Integer.toString(INT_VALIDES[i])) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode compareTo()
     */
    public void testCompareTo() {
        final Entier REF_MIN = new Entier(MIN_VALUE);
        final Entier REF_MAX = new Entier(MAX_VALUE);
        System.out.println("\tExécution du test de compareTo()");
        for (int i = 2; i < ENTIERS_INT.length; i++) {
            assertTrue(REF_MIN.compareTo(ENTIERS_INT[i]) < 0);
            assertTrue(REF_MAX.compareTo(ENTIERS_INT[i]) > 0);
        }
        
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(ENTIERS_INT[i].compareTo(new Entier(INT_VALIDES[i])) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode getValeur()
     */
    @SuppressWarnings("boxing")
    public void testGetValeur() {
        final Integer[] ATTENDUS = {
                MIN_VALUE,
                MAX_VALUE,
                1,
                -4587,
                -569,
                -3,
                0,
                2,
                78,
                781,
                179892,
        };
        System.out.println("\tExécution du test de getValeur()");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(ENTIERS_INT[i].getValeur().compareTo(ATTENDUS[i]) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode somme(Entier, Entier)
     */
    public void testSomme() {
        final Entier[] ATTENDUS = {
                new Entier(MIN_VALUE + MIN_VALUE),
                new Entier(MAX_VALUE + MAX_VALUE),
                new Entier(1 + 1),
                new Entier(-9174),
                new Entier(-1138),
                new Entier(-6),
                new Entier(0),
                new Entier(4),
                new Entier(156),
                new Entier(1562),
                new Entier(359784),
        };
        System.out.println("\tExécution du test de somme(Entier, Entier)");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(somme(ENTIERS_INT[i], ENTIERS_INT[i])
                       .compareTo(ATTENDUS[i]) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode soustrait()
     */
    public void testSoustrait() {
        Entier zero = new Entier(0); 
        System.out.println("\tExécution du test de soustrait(Entier, Entier)");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(soustrait(ENTIERS_INT[i], ENTIERS_INT[i])
                       .compareTo(zero) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode multiplie()
     */
    public void testMultiplie() {
        final Entier[] ATTENDUS = {
                new Entier(MIN_VALUE * MIN_VALUE),
                new Entier(MAX_VALUE * MAX_VALUE),
                new Entier(1 * 1),
                new Entier(-4587 * (-4587)),
                new Entier(-569 * (-569)),
                new Entier(-3 * (-3)),
                new Entier(0 * 0),
                new Entier(2 * 2),
                new Entier(78 * 78),
                new Entier(781 * 781),
                new Entier(179892 * 179892),
        };
        System.out.println("\tExécution du test de multiplie(Entier, Entier)");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(multiplie(ENTIERS_INT[i], ENTIERS_INT[i])
                       .compareTo(ATTENDUS[i]) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode quotient()
     */
    public void testQuotient() {
        final Entier DIVISEUR = new Entier(2);
        
        final Entier[] ATTENDUS = {
                new Entier(-1073741824),
                new Entier(1073741823),
                new Entier(0),
                new Entier(-2293),
                new Entier(-284),
                new Entier(-1),
                new Entier(0),
                new Entier(1),
                new Entier(39),
                new Entier(390),
                new Entier(89946)
        };
        System.out.println("\tExécution du test de quotient(Entier, Entier)");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(quotient(ENTIERS_INT[i], DIVISEUR)
                       .compareTo(ATTENDUS[i]) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode quotient()
     */
    public void testQuotientParZero() {
        final Entier DIVISEUR = new Entier(0);
        System.out.println("\tExécution du test de "
                           + "quotient(Entier, Entier) par 0");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            try {
                quotient(ENTIERS_INT[i], DIVISEUR);
                echec();
            } catch (ExecutionException lancee) {
                // Test OK
            }
        }
    }
    
    /** 
     * Test unitaire de la méthode quotient()
     */
    public void testReste() {
        final Entier DIVISEUR = new Entier(2);
        
        final Entier[] ATTENDUS = {
                new Entier(0),
                new Entier(1),
                new Entier(1),
                new Entier(-1),
                new Entier(-1),
                new Entier(-1),
                new Entier(0),
                new Entier(0),
                new Entier(0),
                new Entier(1),
                new Entier(0)
        };
        System.out.println("\tExécution du test de reste(Entier, Entier)");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            assertTrue(reste(ENTIERS_INT[i], DIVISEUR)
                       .compareTo(ATTENDUS[i]) == 0);
        }
    }
    
    /** 
     * Test unitaire de la méthode quotient()
     */
    public void testResteParZero() {
        final Entier DIVISEUR = new Entier(0);
        System.out.println("\tExécution du test de "
                           + "reste(Entier, Entier) par 0");
        for (int i = 0; i < ENTIERS_INT.length; i++) {
            try {
                reste(ENTIERS_INT[i], DIVISEUR);
                echec();
            } catch (ExecutionException lancee) {
                // Test OK
            }
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de quotient(Entier, Entier) par 0
Réussite de testQuotientParZero
    Exécution du test de Entier(String)
Réussite de testEntierString
    Exécution du test de getValeur()
Réussite de testGetValeur
    Exécution du test de soustrait(Entier, Entier)
Réussite de testSoustrait
    Exécution du test de quotient(Entier, Entier)
Réussite de testQuotient
    Exécution du test de compareTo()
Réussite de testCompareTo
    Exécution du test de multiplie(Entier, Entier)
Réussite de testMultiplie
    Exécution du test de reste(Entier, Entier)
Réussite de testReste
    Exécution du test de Entier(String)
Réussite de testToString
    Exécution du test de somme(Entier, Entier)
Réussite de testSomme
    Exécution du test de reste(Entier, Entier) par 0
Réussite de testResteParZero
\end{verbatim}

    \item interpreteurlir.expression.tests.TestExpression
\begin{verbatim}
/**
 * TestExpression.java                              7 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.expressions.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.expressions.Expression;
import interpreteurlir.expressions.ExpressionChaine;
import interpreteurlir.expressions.ExpressionEntier;
import interpreteurlir.Contexte;

/**
 * Tests unitaires de {@link Expression}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestExpression {
    
    /**
     * Tests unitaires de {@link Expression#referencerContexte(Contexte)}
     */
    public void testReferencerContexte() {

        Contexte reference = new Contexte();
        Contexte[] contextes = {
                null, reference, reference, new Contexte()
        };
        
        boolean[] resultatAttendu = { false, true, true, false };
        
        System.out.println("\tExécution du test de "
                + "Expression#referencerContexte(Contexte)");
        for (int numTest = 0 ; numTest < contextes.length ;  numTest++) {
            assertTrue(   Expression.referencerContexte(contextes[numTest]) 
                       == resultatAttendu[numTest]);
        }
    }
    
    /**
     * Tests unitaires de {@link Expression#determinerTypeExpression(String)}
     */
    public void testDeterminerTypeExpression() {
        final String[] TEXTE_EXPRESSION = {
            /* Expression de type chaine */
            "$chaine = \"texte\"",  
            "$chaine=\"tata\"",
            "   $tata  \t  ",
            "   \"une chaine de texte\"",
            "$chaine= \"toto\"+\"titi\"",
            "   $chaine= $toto +\"titi\"",
            "$chaine= \"toto\"+ $titi",
            "$chaine=$toto +$titi",
            "   \"toto\"+\"titi\"",
            "\t$toto +\"titi\"",
            "\"toto\"+ $titi",
            "$toto +    $titi", 
            
            /* Expression de type Entier */
            "78",
            "  entier",
            "78   %89",
            "  entier- nombre",
            "\t  entier/78",
            "entier = 78  ",
            " nombre= nombre + 78",
            " entier =78 *2"
        };
        
        final int INDEX_DEBUT_ENTIER = 12;
        
        System.out.println("\tExécution du test de "
                           + "Expression#determinerTypeExpression(String)");
        
        for (int numTest = 0; numTest < TEXTE_EXPRESSION.length ; numTest++) {
            if (numTest < INDEX_DEBUT_ENTIER) {
                assertTrue(Expression.determinerTypeExpression(
                        TEXTE_EXPRESSION[numTest]) instanceof ExpressionChaine);
            } else {
                assertTrue(Expression.determinerTypeExpression(
                        TEXTE_EXPRESSION[numTest]) instanceof ExpressionEntier);
            }
        }
    }
    

}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de Expression#referencerContexte(Contexte)
Réussite de testReferencerContexte
    Exécution du test de Expression#determinerTypeExpression(String)
Réussite de testDeterminerTypeExpression
\end{verbatim}

    \item interpreteurlir.expression.tests.TestExpressionBooleenne
\begin{verbatim}
/**
 * TestExpressionBooleenne.java                              21 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.expressions.tests;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurChaine;
import interpreteurlir.donnees.IdentificateurEntier;
import interpreteurlir.donnees.litteraux.Chaine;
import interpreteurlir.donnees.litteraux.Entier;
import interpreteurlir.expressions.Expression;
import interpreteurlir.expressions.ExpressionBooleenne;
import static info1.outils.glg.Assertions.*;

/** 
 * Tests unitaires des méthodes de la classe ExpressionBooleenne
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestExpressionBooleenne {
    
    private final ExpressionBooleenne[] FIXTURE_LITTERALE = {
        /* Expression logique sur des Entiers AVEC ESPACES */
        new ExpressionBooleenne("1 = 1"), // true
        new ExpressionBooleenne("1 = 2"), // false
        new ExpressionBooleenne("1 < 2"),
        new ExpressionBooleenne("1 < 1"),
        new ExpressionBooleenne("1 <> 2"),
        new ExpressionBooleenne("1 <> 1"),
        new ExpressionBooleenne("1 <= 1"),
        new ExpressionBooleenne("1 <= 5"),
        new ExpressionBooleenne("1 > -3"),
        new ExpressionBooleenne("1 > 56"),
        new ExpressionBooleenne("1 >= 1"),
        new ExpressionBooleenne("1 >= 45"),
        /* Expression logique sur des Entiers SANS ESPACES */
        new ExpressionBooleenne("1=1"),
        new ExpressionBooleenne("1=2"),
        new ExpressionBooleenne("1<2"),
        new ExpressionBooleenne("1<1"),
        new ExpressionBooleenne("1<>2"),
        new ExpressionBooleenne("1<>1"),
        new ExpressionBooleenne("1<=1"),
        new ExpressionBooleenne("1<=5"),
        new ExpressionBooleenne("1>-3"),
        new ExpressionBooleenne("1>56"),
        new ExpressionBooleenne("1>=1"),
        new ExpressionBooleenne("1>=45"),
        /* Expression logique sur des Entiers MOITIE ESPACES */
        new ExpressionBooleenne("    1=1"),
        new ExpressionBooleenne("1=2    "),
        new ExpressionBooleenne("1 <2"),
        new ExpressionBooleenne("1< 1"),
        new ExpressionBooleenne("1  <>2"),
        new ExpressionBooleenne("1<>   1"),
        new ExpressionBooleenne("   1<=1   "),
        new ExpressionBooleenne("1   <=   5"),
        new ExpressionBooleenne("    1   >  -3   "),
        new ExpressionBooleenne("1>56\t"),
        new ExpressionBooleenne("   1    >=  1    "),
        new ExpressionBooleenne("    1       >=    45   "),
        
        /* Expression logique sur des Chaines AVEC ESPACES */
        new ExpressionBooleenne("\"TATA\" = \"TATA\""),
        new ExpressionBooleenne("\"TATA\" = \"TITI\""),
        new ExpressionBooleenne("\"TATA\" < \"TITI\""),
        new ExpressionBooleenne("\"TOTO\" < \"TITI\""),
        new ExpressionBooleenne("\"TOTO\" <> \"TATA\""),
        new ExpressionBooleenne("\"TATA\" <> \"TATA\""),
        new ExpressionBooleenne("\"TATA\" <= \"TATA\""),
        new ExpressionBooleenne("\"TITI\" <= \"TATA\""),
        new ExpressionBooleenne("\"TATA\" > \"FOO BAR\""),
        new ExpressionBooleenne("\"FOO BAR\" > \"TATA\""),
        new ExpressionBooleenne("\"TATA\" >= \"TATA\""),
        new ExpressionBooleenne("\"FOO BAR\" >= \"TATA\""),
        /* Expression logique sur des Chaines SANS ESPACES */
        new ExpressionBooleenne("\"TATA\"=\"TATA\""),
        new ExpressionBooleenne("\"TATA\"=\"TITI\""),
        new ExpressionBooleenne("\"TATA\"<\"TITI\""),
        new ExpressionBooleenne("\"TOTO\"<\"TITI\""),
        new ExpressionBooleenne("\"TOTO\"<>\"TATA\""),
        new ExpressionBooleenne("\"TATA\"<>\"TATA\""),
        new ExpressionBooleenne("\"TATA\"<=\"TATA\""),
        new ExpressionBooleenne("\"TITI\"<=\"TATA\""),
        new ExpressionBooleenne("\"TATA\">\"FOO BAR\""),
        new ExpressionBooleenne("\"FOO BAR\">\"TATA\""),
        new ExpressionBooleenne("\"TATA\">=\"TATA\""),
        new ExpressionBooleenne("\"FOO BAR\">=\"TATA\""),
        /* Expression logique sur des Chaines MOITIE ESPACES */
        new ExpressionBooleenne("        \"TATA\" = \"TATA\""),
        new ExpressionBooleenne("\"TATA\"           = \"TITI\""),
        new ExpressionBooleenne("\"TATA\" <          \"TITI\""),
        new ExpressionBooleenne("\"TOTO\" < \"TITI\"       "),
        new ExpressionBooleenne("     \"TOTO\"<> \"TATA\"       "),
        new ExpressionBooleenne("\"TATA\"     <>     \"TATA\"     "),
        new ExpressionBooleenne("        \"TATA\" <=\"TATA\""),
        new ExpressionBooleenne("\"TITI\" <=       \"TATA\""),
        new ExpressionBooleenne("      \"TATA\" > \"FOO BAR\""),
        new ExpressionBooleenne("    \"FOO BAR    \"       > \"TATA\""),
        new ExpressionBooleenne("\"TATA\"        >=         \"TATA\""),
        new ExpressionBooleenne("            \"FOO BAR\" >=      \"TATA\""),
        /* Expression logique sur des Chaines AVEC OPERATEURS */
        new ExpressionBooleenne("\"FOO BAR\"<>\"TATA=TOTO\""),
        new ExpressionBooleenne("\"FOO BAR=FLEMME\">\"TOTO\""),
        new ExpressionBooleenne("\"FOO BAR > FLEMME\"=\"TOTO\""),
        new ExpressionBooleenne("\"FOO BAR<>FLEMME\">\"TOTO\""),
        
    };
        
    private final ExpressionBooleenne[] FIXTURE_ID = {
        /* Expression logique sur des IdEntier et Entiers */
        new ExpressionBooleenne("marcel <= 10"), // true
        new ExpressionBooleenne("marcel > j34n"), // false
        new ExpressionBooleenne("2 = pi3rr3"),
        new ExpressionBooleenne("j34n = pi3rr3"),
        /* Expression logique sur des IdChaine et Chaines */
        new ExpressionBooleenne("$sanchis < $barrios"),
        new ExpressionBooleenne("$servieres > \"Windows\""),
        new ExpressionBooleenne("$barrios <> $servieres"),
        new ExpressionBooleenne("\"coucou\" = $barrios"),
    };

    /** 
     * Tests unitaire de {@link ExpressionBooleenne#ExpressionBooleenne(String)}
     */
    public void testExpressionBooleenne() {
        
        final String[] INVALIDES = {
            /* Pas d'opérateur */
            "",
            "2 5",
            "\"John Doe\"",
            "\"Foo bar\" $serpillere",
            "entier -20",
            /* Opérateurs invalides */
            "-89 + 67",
            "-8979 % 7",
            "35 * 12",
            "89 / 12",
            "65 - 74",
            "\"Foo bar\" + $serpillere",
            "ab >> cd",
            /* Expressions logiques avec opérateurs invalides */
            "78 < =  45",
            "entier > = 56",
            "\"Foo bar\" < > $serpillere",
            "$coucou >< $dollarchaine",
            "78 => 45",
            "32 =< 61",
            "32 == 61",
            /* Plus de 2 opérandes et 1 opérateur */
            "65 <> 45 = 45",
            "entier > 85 && 45 = 12",
            "entier <= 85 || 45 <> 12",
            /* Caractères entre les opérandes et l'opérateur */
            "\"Foo bar\"  . > $serpillere",
            "\"Foo bar\"  < _ $serpillere",
            "\"Foo bar\" + $balai > serpillere",
            /* opérande manquant */
            ">= entier",
            "entier =",
            "<>",
            /* Incompatibilité entre types d'opérandes */
            "\"Foo bar\" > serpillere",
            "serpillere <> \"Foo bar\"",
            "15 > $coucou",
            "\"coucou\" <> 45",
            "$coucou = entier"
        };

        System.out.println("\tExécution du test de ExpressionBooleenne()");
        
        for (String aTester : INVALIDES) {
            try {
                new ExpressionBooleenne(aTester);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        try {
            /* Expression logique sur des Entiers AVEC ESPACES */
            new ExpressionBooleenne("1 = 1"); // true
            new ExpressionBooleenne("1 = 2"); // false
            new ExpressionBooleenne("1 < 2");
            new ExpressionBooleenne("1 < 1");
            new ExpressionBooleenne("1 <> 2");
            new ExpressionBooleenne("1 <> 1");
            new ExpressionBooleenne("1 <= 1");
            new ExpressionBooleenne("1 <= 5");
            new ExpressionBooleenne("1 > -3");
            new ExpressionBooleenne("1 > 56");
            new ExpressionBooleenne("1 >= 1");
            new ExpressionBooleenne("1 >= 45");
            /* Expression logique sur des Entiers SANS ESPACES */
            new ExpressionBooleenne("1=1");
            new ExpressionBooleenne("1=2");
            new ExpressionBooleenne("1<2");
            new ExpressionBooleenne("1<1");
            new ExpressionBooleenne("1<>2");
            new ExpressionBooleenne("1<>1");
            new ExpressionBooleenne("1<=1");
            new ExpressionBooleenne("1<=5");
            new ExpressionBooleenne("1>-3");
            new ExpressionBooleenne("1>56");
            new ExpressionBooleenne("1>=1");
            new ExpressionBooleenne("1>=45");
            /* Expression logique sur des Entiers MOITIE ESPACES */
            new ExpressionBooleenne("    1=1");
            new ExpressionBooleenne("1=2    ");
            new ExpressionBooleenne("1 <2");
            new ExpressionBooleenne("1< 1");
            new ExpressionBooleenne("1  <>2");
            new ExpressionBooleenne("1<>   1");
            new ExpressionBooleenne("   1<=1   ");
            new ExpressionBooleenne("1   <=   5");
            new ExpressionBooleenne("    1   >  -3   ");
            new ExpressionBooleenne("1>56\t");
            new ExpressionBooleenne("   1    >=  1    ");
            new ExpressionBooleenne("    1       >=    45   ");
            
            /* Expression logique sur des Chaines AVEC ESPACES */
            new ExpressionBooleenne("\"TATA\" = \"TATA\"");
            new ExpressionBooleenne("\"TATA\" = \"TITI\"");
            new ExpressionBooleenne("\"TATA\" < \"TITI\"");
            new ExpressionBooleenne("\"TOTO\" < \"TITI\"");
            new ExpressionBooleenne("\"TOTO\" <> \"TATA\"");
            new ExpressionBooleenne("\"TATA\" <> \"TATA\"");
            new ExpressionBooleenne("\"TATA\"<=\"TATA\"");
            new ExpressionBooleenne("\"TITI\" <= \"TATA\"");
            new ExpressionBooleenne("\"TATA\" > \"FOO BAR\"");
            new ExpressionBooleenne("\"FOO BAR\" > \"TATA\"");
            new ExpressionBooleenne("\"TATA\" >= \"TATA\"");
            new ExpressionBooleenne("\"FOO BAR\" >= \"TATA\"");
            /* Expression logique sur des Chaines SANS ESPACES */
            new ExpressionBooleenne("\"TATA\"=\"TATA\"");
            new ExpressionBooleenne("\"TATA\"=\"TITI\"");
            new ExpressionBooleenne("\"TATA\"<\"TITI\"");
            new ExpressionBooleenne("\"TOTO\"<\"TITI\"");
            new ExpressionBooleenne("\"TOTO\"<>\"TATA\"");
            new ExpressionBooleenne("\"TATA\"<>\"TATA\"");
            new ExpressionBooleenne("\"TATA\"<=\"TATA\"");
            new ExpressionBooleenne("\"TITI\"<=\"TATA\"");
            new ExpressionBooleenne("\"TATA\">\"FOO BAR\"");
            new ExpressionBooleenne("\"FOO BAR\">\"TATA\"");
            new ExpressionBooleenne("\"TATA\">=\"TATA\"");
            new ExpressionBooleenne("\"FOO BAR\">=\"TATA\"");
            /* Expression logique sur des Chaines MOITIE ESPACES */
            new ExpressionBooleenne("        \"TATA\" = \"TATA\"");
            new ExpressionBooleenne("\"TATA\"           = \"TITI\"");
            new ExpressionBooleenne("\"TATA\" <          \"TITI\"");
            new ExpressionBooleenne("\"TOTO\" < \"TITI\"       ");
            new ExpressionBooleenne("     \"TOTO\"<> \"TATA\"       ");
            new ExpressionBooleenne("\"TATA\"     <>     \"TATA\"     ");
            new ExpressionBooleenne("        \"TATA\" <=\"TATA\"");
            new ExpressionBooleenne("\"TITI\" <=       \"TATA\"");
            new ExpressionBooleenne("      \"TATA\" > \"FOO BAR\"");
            new ExpressionBooleenne("    \"FOO BAR    \"       > \"TATA\"");
            new ExpressionBooleenne("\"TATA\"        >=         \"TATA\"");
            new ExpressionBooleenne("            \"FOO BAR\" >=      \"TATA\"");
            /* Expression logique sur des Chaines AVEC OPERATEURS */
            new ExpressionBooleenne("\"FOO BAR\"<>\"TATA=TOTO\"");
            new ExpressionBooleenne("\"FOO BAR=FLEMME\">\"TOTO\"");
            new ExpressionBooleenne("\"FOO BAR > FLEMME\"=\"TOTO\"");
            new ExpressionBooleenne("\"FOO BAR<>FLEMME\">\"TOTO\"");

            /* Expression logique sur des IdEntier et Entiers */
            new ExpressionBooleenne("marcel <= 10"); // true
            new ExpressionBooleenne("marcel > j34n"); // false
            new ExpressionBooleenne("2 = pi3rr3");
            new ExpressionBooleenne("j34n = pi3rr3");
            /* Expression logique sur des IdChaine et Chaines */
            new ExpressionBooleenne("$sanchis < $barrios");
            new ExpressionBooleenne("$servieres > \"Windows\"");
            new ExpressionBooleenne("$barrios <> $servieres");
            new ExpressionBooleenne("\"coucou\" = $barrios");
        } catch (InterpreteurException lancee) {
            echec();
        }
    }
    
    /** 
     * Tests unitaire de {@link ExpressionBooleenne#calculer()}
     */
    public void testCalculer() {
        
        final Boolean[] VALEUR_ATTENDU_ID = {
                true, false, true, false, true, false, true, false
        };
        
        
        Contexte contexteGlobal = new Contexte();
        contexteGlobal.ajouterVariable(new IdentificateurEntier("marcel"),
                                       new Entier(0));
        contexteGlobal.ajouterVariable(new IdentificateurEntier("j34n"),
                                       new Entier(1));
        contexteGlobal.ajouterVariable(new IdentificateurEntier("pi3rr3"),
                                       new Entier(2));
        contexteGlobal.ajouterVariable(new IdentificateurChaine("$sanchis"),
                new Chaine("\"coucou\""));
        contexteGlobal.ajouterVariable(new IdentificateurChaine("$barrios"),
                new Chaine("\"java\""));
        contexteGlobal.ajouterVariable(new IdentificateurChaine("$servieres"),
                new Chaine("\"WinDesign\""));
        Expression.referencerContexte(contexteGlobal);

        System.out.println("\tExécution du test de Calculer()");
        for (int numTest = 0 ; numTest < VALEUR_ATTENDU_ID.length ; numTest++) {
            assertEquivalence(VALEUR_ATTENDU_ID[numTest], 
                              FIXTURE_ID[numTest].calculer().getValeur());
        }
        
        final ExpressionBooleenne[] A_TESTER = {
                new ExpressionBooleenne("1=1"),
                new ExpressionBooleenne("1=2"),
                new ExpressionBooleenne("1<2"),
                new ExpressionBooleenne("1<1"),
                new ExpressionBooleenne("1<>2"),
                new ExpressionBooleenne("1<>1"),
                new ExpressionBooleenne("1<=1"),
                new ExpressionBooleenne("1<=5"),
                new ExpressionBooleenne("1>-3"),
                new ExpressionBooleenne("1>56"),
                new ExpressionBooleenne("1>=1"),
                new ExpressionBooleenne("1>=45"),
                new ExpressionBooleenne("\"TATA\" = \"TATA\""),
                new ExpressionBooleenne("\"TATA\" = \"TITI\""),
                new ExpressionBooleenne("\"TATA\" < \"TITI\""),
                new ExpressionBooleenne("\"TOTO\" < \"TITI\""),
                new ExpressionBooleenne("\"TOTO\" <> \"TATA\""),
                new ExpressionBooleenne("\"TATA\" <> \"TATA\""),
                new ExpressionBooleenne("\"TATA\"<=\"TATA\""),
                new ExpressionBooleenne("\"TITI\" <= \"TATA\""),
                new ExpressionBooleenne("\"TATA\" > \"FOO BAR\""),
                new ExpressionBooleenne("\"FOO BAR\" > \"TATA\""),
                new ExpressionBooleenne("\"TATA\" >= \"TATA\""),
                new ExpressionBooleenne("\"FOO BAR\" >= \"TATA\""),
        };
        
        final Boolean[] VALEUR_ATTENDU_L = {
                true, false, true, false, true, false, 
                true, true, true, false, true, false, 
                
                true, false, true, false, true, false,
                true, false, true, false, true, false
        };
        
        for (int numTest = 0 ; numTest < A_TESTER.length ; numTest++) {
          assertEquivalence(VALEUR_ATTENDU_L[numTest], 
                            A_TESTER[numTest].calculer().getValeur());
      }
    }
    
    /** 
     * Tests unitaire de {@link ExpressionBooleenne#toString()}
     */
    public void testToString() {
        System.out.println("\tExécution du test de toString()");
        
        final String[] ATTENDU_L = {
                "1 = 1",
                "1 = 2",
                "1 < 2",
                "1 < 1",
                "1 <> 2",
                "1 <> 1",
                "1 <= 1",
                "1 <= 5",
                "1 > -3",
                "1 > 56",
                "1 >= 1",
                "1 >= 45",
                "1 = 1",
                "1 = 2",
                "1 < 2",
                "1 < 1",
                "1 <> 2",
                "1 <> 1",
                "1 <= 1",
                "1 <= 5",
                "1 > -3",
                "1 > 56",
                "1 >= 1",
                "1 >= 45",
                "1 = 1",
                "1 = 2",
                "1 < 2",
                "1 < 1",
                "1 <> 2",
                "1 <> 1",
                "1 <= 1",
                "1 <= 5",
                "1 > -3",
                "1 > 56",
                "1 >= 1",
                "1 >= 45",
                "\"TATA\" = \"TATA\"",
                "\"TATA\" = \"TITI\"",
                "\"TATA\" < \"TITI\"",
                "\"TOTO\" < \"TITI\"",
                "\"TOTO\" <> \"TATA\"",
                "\"TATA\" <> \"TATA\"",
                "\"TATA\" <= \"TATA\"",
                "\"TITI\" <= \"TATA\"",
                "\"TATA\" > \"FOO BAR\"",
                "\"FOO BAR\" > \"TATA\"",
                "\"TATA\" >= \"TATA\"",
                "\"FOO BAR\" >= \"TATA\"",
                "\"TATA\" = \"TATA\"",
                "\"TATA\" = \"TITI\"",
                "\"TATA\" < \"TITI\"",
                "\"TOTO\" < \"TITI\"",
                "\"TOTO\" <> \"TATA\"",
                "\"TATA\" <> \"TATA\"",
                "\"TATA\" <= \"TATA\"",
                "\"TITI\" <= \"TATA\"",
                "\"TATA\" > \"FOO BAR\"",
                "\"FOO BAR\" > \"TATA\"",
                "\"TATA\" >= \"TATA\"",
                "\"FOO BAR\" >= \"TATA\"",
                "\"TATA\" = \"TATA\"",
                "\"TATA\" = \"TITI\"",
                "\"TATA\" < \"TITI\"",
                "\"TOTO\" < \"TITI\"",
                "\"TOTO\" <> \"TATA\"",
                "\"TATA\" <> \"TATA\"",
                "\"TATA\" <= \"TATA\"",
                "\"TITI\" <= \"TATA\"",
                "\"TATA\" > \"FOO BAR\"",
                "\"FOO BAR    \" > \"TATA\"",
                "\"TATA\" >= \"TATA\"",
                "\"FOO BAR\" >= \"TATA\"",
                "\"FOO BAR\" <> \"TATA=TOTO\"",
                "\"FOO BAR=FLEMME\" > \"TOTO\"",
                "\"FOO BAR > FLEMME\" = \"TOTO\"",
                "\"FOO BAR<>FLEMME\" > \"TOTO\"",
        };
        
        for (int numTest = 0 ; numTest < ATTENDU_L.length ; numTest++) {
            assertEquivalence(ATTENDU_L[numTest], 
                              FIXTURE_LITTERALE[numTest].toString());
        }
        
        final String[] ATTENDU_I = {
                "marcel <= 10",
                "marcel > j34n",
                "2 = pi3rr3",
                "j34n = pi3rr3",
                "$sanchis < $barrios",
                "$servieres > \"Windows\"",
                "$barrios <> $servieres",
                "\"coucou\" = $barrios",
        };
        
        for (int numTest = 0 ; numTest < ATTENDU_I.length ; numTest++) {
            assertEquivalence(ATTENDU_I[numTest], 
                              FIXTURE_ID[numTest].toString());
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de ExpressionBooleenne()
Réussite de testExpressionBooleenne
    Exécution du test de Calculer()
Réussite de testCalculer
    Exécution du test de toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.expression.tests.TestExpressionChaine
\begin{verbatim}
/**
 * TestExpressionChaine.java                              7 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.expressions.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurChaine;
import interpreteurlir.donnees.litteraux.Chaine;
import interpreteurlir.expressions.Expression;
import interpreteurlir.expressions.ExpressionChaine;

/**
 * Tests unitaires de {@link ExpressionChaine}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestExpressionChaine {
    
    /** Jeu de tests d'expression chaîne valides*/
    private ExpressionChaine[] fixture = {
        new ExpressionChaine("$chaine = \"texte\""),  
        new ExpressionChaine("$chaine=\"tata\""),
        new ExpressionChaine("   $tata  \t  "),
        new ExpressionChaine("\"une chaine de texte\""),
        new ExpressionChaine("$chaine= \"toto\"+\"titi\""),
        new ExpressionChaine("$chaine= $toto +\"titi\""),
        new ExpressionChaine("$chaine= \"toto\"+ $titi"),
        new ExpressionChaine("$chaine=$toto +$titi"),
        new ExpressionChaine("   \"toto\"+\"titi\""),
        new ExpressionChaine("$toto +\"titi\""),
        new ExpressionChaine("\"toto\"+ $titi"),
        new ExpressionChaine("$toto +    $titi"),
        new ExpressionChaine("\"ab=bc\""),
        new ExpressionChaine("$chaine = \"ab+cd\"+$toto")
    };

    /**
     * Tests unitaires de {@link ExpressionChaine#ExpressionChaine(String)}
     */
    public void testExpressionChaineString() {
        
        final String[] INVALIDES = {
            null,    
            "",
            "3,1415", "3.1415", "1.7976931348623157E308",
            "45", "-89",
            "tata + $toto",
            "\"chaine\" = $vie",
            "$chaine / \"tata\"",
            "£", "$" 
        };
        
        final String[] VALIDES = {
            "$chaine = \"texte\"",  
            "$chaine=\"tata\"",
            "   $tata  \t  ",
            "\"une chaine de texte\"",
            "$chaine= \"toto\"+\"titi\"",
            "$chaine= $toto +\"titi\"",
            "$chaine= \"toto\"+ $titi",
            "$chaine=$toto +$titi",
            "   \"toto\"+\"titi\"",
            "$toto +\"titi\"",
            "\"toto\"+ $titi",
            "$toto +    $titi",
            "\"ab=bc\"",
            "$chaine = \"ab+cd\"+$toto"
        };
        
        System.out.println("\tExécution du test de "
                + "ExpressionChaine#ExpressionChaine(String)");
        for (String texteArgs : INVALIDES) {
            try {
                new ExpressionChaine(texteArgs);
                echec();
            } catch (InterpreteurException lancee) { 
                // empty
            }
        }
        
        for (String texteArgs : VALIDES) {
            try {
                new ExpressionChaine(texteArgs);
            } catch (InterpreteurException lancee) { 
                echec();
            }
        }     
    }
    
    /**
     * Tests unitaires de {@link ExpressionChaine#calculer()}
     */
    public void testCalculer() {
        final Chaine[] RESULTAT_ATTENDU = {
            new Chaine("\"texte\""),
            new Chaine("\"tata\""),
            new Chaine("\"\""),
            new Chaine("\"une chaine de texte\""),
            new Chaine("\"tototiti\""),
            new Chaine("\"valTototiti\""),
            new Chaine("\"toto\""),
            new Chaine("\"valToto\""),
            new Chaine("\"tototiti\""),
            new Chaine("\"valTototiti\""),
            new Chaine("\"toto\""),
            new Chaine("\"valToto\""),
            new Chaine("\"ab=bc\""),
            new Chaine("\"ab+cdvalToto\"")
        };
        
        System.out.println("\tExécution du test de "
                + "ExpressionChaine#calculer()");
        
        /* Exception levée si contexte non référencé */
        try {
            fixture[0].calculer();
            echec();
        } catch (RuntimeException e) {
            // vide
        }
        
        /* Création contexte (avec $toto = "valToto") et référencement */
        Contexte contexteGlobal = new Contexte();
        contexteGlobal.ajouterVariable(new IdentificateurChaine("$toto"),
                                       new Chaine("\"valToto\""));
        Expression.referencerContexte(contexteGlobal);
        System.out.print("\tContexte initial : \n" + contexteGlobal);
        
        for (int numTest = 0; numTest < RESULTAT_ATTENDU.length ; numTest++) {
            System.out.println("\nCalcul de : " + fixture[numTest]);
            assertEquivalence(fixture[numTest].calculer()
                    .compareTo(RESULTAT_ATTENDU[numTest]), 0);
            System.out.println("\tContexte : \n" + contexteGlobal);
        }
        
    }
    
    /**
     * Tests unitaires de {@link ExpressionChaine#toString()}
     */
    public void testToString() {
        final String[] chaineAttendue = {
            "$chaine = \"texte\"",  
            "$chaine = \"tata\"",
            "$tata",
            "\"une chaine de texte\"",
            "$chaine = \"toto\" + \"titi\"",
            "$chaine = $toto + \"titi\"",
            "$chaine = \"toto\" + $titi",
            "$chaine = $toto + $titi",
            "\"toto\" + \"titi\"",
            "$toto + \"titi\"",
            "\"toto\" + $titi",
            "$toto + $titi",
            "\"ab=bc\"",
            "$chaine = \"ab+cd\" + $toto",
        };
        
        System.out.println("\tExécution du test de "
                           + "ExpressionChaine#toString()");
        for (int numTest = 0 ; numTest < chaineAttendue.length ; numTest++) {
            assertEquivalence(chaineAttendue[numTest], 
                              fixture[numTest].toString());
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de ExpressionChaine#ExpressionChaine(String)
Réussite de testExpressionChaineString
    Exécution du test de ExpressionChaine#calculer()
    Contexte initial : 
$toto = "valToto"

Calcul de : $chaine = "texte"
    Contexte : 
$chaine = "texte"
$toto = "valToto"


Calcul de : $chaine = "tata"
    Contexte : 
$chaine = "tata"
$toto = "valToto"


Calcul de : $tata
    Contexte : 
$chaine = "tata"
$toto = "valToto"


Calcul de : "une chaine de texte"
    Contexte : 
$chaine = "tata"
$toto = "valToto"


Calcul de : $chaine = "toto" + "titi"
    Contexte : 
$chaine = "tototiti"
$toto = "valToto"


Calcul de : $chaine = $toto + "titi"
    Contexte : 
$chaine = "valTototiti"
$toto = "valToto"


Calcul de : $chaine = "toto" + $titi
    Contexte : 
$chaine = "toto"
$toto = "valToto"


Calcul de : $chaine = $toto + $titi
    Contexte : 
$chaine = "valToto"
$toto = "valToto"


Calcul de : "toto" + "titi"
    Contexte : 
$chaine = "valToto"
$toto = "valToto"


Calcul de : $toto + "titi"
    Contexte : 
$chaine = "valToto"
$toto = "valToto"


Calcul de : "toto" + $titi
    Contexte : 
$chaine = "valToto"
$toto = "valToto"


Calcul de : $toto + $titi
    Contexte : 
$chaine = "valToto"
$toto = "valToto"


Calcul de : "ab=bc"
    Contexte : 
$chaine = "valToto"
$toto = "valToto"


Calcul de : $chaine = "ab+cd" + $toto
    Contexte : 
$chaine = "ab+cdvalToto"
$toto = "valToto"

Réussite de testCalculer
    Exécution du test de ExpressionChaine#toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.expression.tests.TestExpressionEntier
\begin{verbatim}
/**
 * TestExpressionEntier.java                              7 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.expressions.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurEntier;
import interpreteurlir.donnees.litteraux.Entier;
import interpreteurlir.expressions.Expression;
import interpreteurlir.expressions.ExpressionEntier;

/**
 * Tests unitaires de {@link ExpressionEntier}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestExpressionEntier {
    
    /* jeu de test d'expressions entières valides */
    private static final ExpressionEntier[] FIXTURE = {
        new ExpressionEntier("entier = 2 + 3"),
        new ExpressionEntier("entier=2*3"),
        new ExpressionEntier("bob= marcel-2"),
        new ExpressionEntier("45 +14"),
        new ExpressionEntier("45 * -2"),
        new ExpressionEntier("affectation = 64"),
        new ExpressionEntier("affectation= marcel"),
        new ExpressionEntier("entier = j34n + pi3rr3"),
        new ExpressionEntier("       entier   = j34n"),
        new ExpressionEntier("    42"),
        new ExpressionEntier("rep0ns3=  42"),
        new ExpressionEntier("division = 12/0"),
        new ExpressionEntier("modulo = 12%0")
    };
    
    /**
     * Tests unitaires de {@link ExpressionEntier#ExpressionEntier(String)}
     */
    public static void testExpressionEntierString() {
        final String[] INVALIDES = {
            /* identificateurs non valides */
            "$bob =2",
            "j@ck= 2+3",
            "@75S= #michel",
            "unidentificateurbeaucouptroplong = 0",
            "truc.length = 9000",
            
            /* types non compatibles */
            "resultat = \"50\"",
            "resultat = 30.2",
            "resultat = 10 / 2.0",
            
            /* Nombre incorrect d'opérandes */
            "resultat = 10 * 5 + 3",
            "famille = marcel + jean + albert",
            "divisionRatee = 5 /",
            "ratee=*7",
        };
        System.out.println("\tExécution du test de "
                           + "ExpressionEntier#ExpressionEntier(String)");
        for (String invalide : INVALIDES) {
            try {
                new ExpressionEntier(invalide);
                echec();
                
            } catch(InterpreteurException | ExecutionException lancee) {
                // Empty body
            }
        }
    }
    
    /**
     * Tests unitaires de {@link ExpressionEntier#calculer()}
     */
    public static void testCalculer() {
        final Entier[] RESULTATS_ATTENDUS = {
            new Entier(5),
            new Entier(6),
            new Entier(-2),
            new Entier(59),
            new Entier(-90),
            new Entier(64),
            new Entier(0),
            new Entier(3),
            new Entier(1),
            new Entier(42),
            new Entier(42),
            new Entier(0),  // Bouchon
            new Entier(0)   // Bouchon
        };
        
        System.out.println("\tExécution du test de "
                           + "ExpressionEntier#calculer()");
        
        /* Exception levée si contexte non référencé */
        try {
            FIXTURE[0].calculer();
            echec();
        } catch (RuntimeException e) {
            // vide
        }
        
        /* 
         * Création contexte (avec marcel = 0 j34n = 1 et pi3rr3 = 2) et 
         * référencement 
         */
        Contexte contexteGlobal = new Contexte();
        contexteGlobal.ajouterVariable(new IdentificateurEntier("marcel"),
                                       new Entier(0));
        contexteGlobal.ajouterVariable(new IdentificateurEntier("j34n"),
                                       new Entier(1));
        contexteGlobal.ajouterVariable(new IdentificateurEntier("pi3rr3"),
                                       new Entier(2));
        Expression.referencerContexte(contexteGlobal);
        System.out.print("\tContexte initial : \n" + contexteGlobal);
        
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            try {
                System.out.println("\nCalcul de : " + FIXTURE[i]);
                assertTrue(FIXTURE[i].calculer()
                                     .compareTo(RESULTATS_ATTENDUS[i]) == 0);
                System.out.println("\tContexte : \n" + contexteGlobal);
            } catch (ExecutionException divzero) {
                System.out.println("Attention Division par 0");
            }
        }
    }
    
    /**
     * test de toString()
     */
    public static void testToString() {
        final String[] ATTENDUES = {
                "entier = 2 + 3",
                "entier = 2 * 3",
                "bob = marcel - 2",
                "45 + 14",
                "45 * -2",
                "affectation = 64",
                "affectation = marcel",
                "entier = j34n + pi3rr3",
                "entier = j34n",
                "42",
                "rep0ns3 = 42",
                "division = 12 / 0",
                "modulo = 12 % 0"
        };
        
        System.out.println("\tExécution du test de "
                           + "ExpressionEntier#toString()");
        
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            assertTrue(FIXTURE[i].toString().equals(ATTENDUES[i]));
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de ExpressionEntier#calculer()
    Contexte initial : 
j34n = 1
marcel = 0
pi3rr3 = 2

Calcul de : entier = 2 + 3
    Contexte : 
entier = 5
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : entier = 2 * 3
    Contexte : 
entier = 6
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : bob = marcel - 2
    Contexte : 
bob = -2
entier = 6
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : 45 + 14
    Contexte : 
bob = -2
entier = 6
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : 45 * -2
    Contexte : 
bob = -2
entier = 6
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : affectation = 64
    Contexte : 
affectation = 64
bob = -2
entier = 6
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : affectation = marcel
    Contexte : 
affectation = 0
bob = -2
entier = 6
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : entier = j34n + pi3rr3
    Contexte : 
affectation = 0
bob = -2
entier = 3
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : entier = j34n
    Contexte : 
affectation = 0
bob = -2
entier = 1
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : 42
    Contexte : 
affectation = 0
bob = -2
entier = 1
j34n = 1
marcel = 0
pi3rr3 = 2


Calcul de : rep0ns3 = 42
    Contexte : 
affectation = 0
bob = -2
entier = 1
j34n = 1
marcel = 0
pi3rr3 = 2
rep0ns3 = 42


Calcul de : division = 12 / 0
Attention Division par 0

Calcul de : modulo = 12 % 0
Attention Division par 0
Réussite de testCalculer
    Exécution du test de ExpressionEntier#toString()
Réussite de testToString
    Exécution du test de ExpressionEntier#ExpressionEntier(String)
Réussite de testExpressionEntierString
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeCharge
\begin{verbatim}
/**
 * TestCommandeCharge.java                              21 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.tests;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.CommandeCharge;
import interpreteurlir.motscles.CommandeListe;
import interpreteurlir.programmes.Programme;

import static info1.outils.glg.Assertions.*;

/** 
 * Tests unitaires de {@link interpreteurlir.motscles.CommandeCharge}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestCommandeCharge {

    /** Contexte pour tests */
    private final static Contexte CONTEXTE_TESTS = new Contexte();

    /** Programme global pour tests */
    private static Programme progGlobal = new Programme();

    /** jeu de test valide */
    public static final CommandeCharge[] FIXTURE = {
            new CommandeCharge("F:\\Programmation\\WorkspaceInterpreteurLIR"
                               + "\\outilTest\\dossierFichier\\"
                               + "lefichier1.lir", CONTEXTE_TESTS),
            new CommandeCharge("dossierFichier\\lefichier2.lir",
                               CONTEXTE_TESTS),
            new CommandeCharge("dossierFichier\\lefichier3.lir",
                               CONTEXTE_TESTS),
            new CommandeCharge("dossierFichier\\test\\lefichier4.lir",
                               CONTEXTE_TESTS),
            new CommandeCharge("dossierFichier\\test\\test2\\lefichier5.lir",
                               CONTEXTE_TESTS),
            new CommandeCharge("     dossierFichier\\lefichier6.lir     ",
                               CONTEXTE_TESTS),
            new CommandeCharge("dossierFichier\\test\\test2\\..\\lefichier7.lir",
                    CONTEXTE_TESTS)
    };

    /**
     * Tests unitaires de
     * {@link CommandeCharge#CommandeCharge(String, Contexte)}
     */
    public static void testCommandeCharge() {

        final String[] INVALIDE = {
                null,
                "    ",
                "",
                "lefichier",
                "dossier\\      lefichier",
                "dossier        \\lefichier",
        };

        for (int i = 0; i < INVALIDE.length ; i++) {
            try {
                new CommandeCharge(INVALIDE[i], CONTEXTE_TESTS);
                echec();
            } catch (InterpreteurException | NullPointerException lancee) {
                // Test OK
            }
        }
    }
    
    /**
     * Tests unitaires de
     * {@link CommandeCharge#executer()}
     */
    public static void testExecuter() {
        
        Commande.referencerProgramme(progGlobal);
        
        final CommandeCharge[] ERREUR = {
                new CommandeCharge("dossierFichier\\erreur1.lir",
                                   CONTEXTE_TESTS),
                new CommandeCharge("dossierFichier\\erreur2.lir",
                                   CONTEXTE_TESTS)
        };
        
        final int NB_TESTS = FIXTURE.length;
        System.out.println("\nTest valides de CommandeCharge#executer():");
        for (int i = 0; i < NB_TESTS ; i++) {
            System.out.println("Test " + (i+1) + '\\' + NB_TESTS + ":");
            FIXTURE[i].executer();
            new CommandeListe("", CONTEXTE_TESTS).executer();
        }
        
        System.out.println("\nTest invalides de CommandeCharge#executer():");
        for(int i = 0; i < ERREUR.length ; i++) {
            try {
                ERREUR[i].executer();
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
                new CommandeListe("", CONTEXTE_TESTS).executer();
            }
        }
    }

}
\end{verbatim}
Resultat:
\begin{verbatim}
Test valides de CommandeCharge#executer():
Test 1\7:
5 var $test = "fichier1 OK"
10 stop
Test 2\7:
5 var $test = "fichier2 OK"
10 stop
Test 3\7:
5 var $test = "fichier3 OK"
10 stop
Test 4\7:
5 var $test = "fichier4 OK"
10 stop
Test 5\7:
5 var $test = "fichier5 OK"
10 stop
Test 6\7:
5 var $test = "fichier6 OK"
10 stop
Test 7\7:
5 var $test = "fichier7 OK"
10 stop

Test invalides de CommandeCharge#executer():
aucune ligne à afficher
aucune ligne à afficher
Réussite de testExecuter
Réussite de testCommandeCharge
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeDebut
\begin{verbatim}
/**
 * TestCommandeDebut.java                              7 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.InterpreteurException;
import interpreteurlir.Contexte;
import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.CommandeDebut;
import interpreteurlir.programmes.Programme;

/**
 * Tests unitaires de {@link interpreteurlir.motscles.CommandeDebut}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestCommandeDebut {
 
    /** Jeux d'essais de CommandeDebut valides pour les tests */
    private CommandeDebut[] fixture = { 
            new CommandeDebut("", new Contexte()),
            new CommandeDebut("    ", new Contexte()),
            new CommandeDebut("\t", new Contexte()),
    };
    
    /**
     * Tests unitaires de {@link CommandeDebut#CommandeDebut(String, Contexte)}
     */
    public void testCommandeDebutStringContexte() {
        System.out.println("\tExécution du test de CommandeDebut"
                           + "#CommandeDebut(String, Contexte)");
        
        /* Tests Commande invalide */
        String[] arguments = { "$chaine", " a   ", "fin" };
        Contexte contexte = new Contexte();
        for (int numTest = 0 ; numTest < arguments.length ; numTest++) {
            try {
                new CommandeDebut(arguments[numTest], contexte);
                echec();
            } catch (InterpreteurException lancee) { 
            }
        }
        
        try {
            new CommandeDebut("", new Contexte());
            new CommandeDebut("    ", new Contexte());
            new CommandeDebut("\t", new Contexte());
        } catch (InterpreteurException e) {
            echec();
        }
    }
    
    
    /**
     * Tests unitaires de {@link CommandeDebut#executer()}
     */
    public void testExecuter() {
        Commande.referencerProgramme(new Programme());
        System.out.println("\tExécution du test de CommandeDebut#executer()");
        for (CommandeDebut cmd : fixture) {
            assertFalse(cmd.executer());
        }
        
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeDebut#executer()
Réussite de testExecuter
    Exécution du test de CommandeDebut#CommandeDebut(String, Contexte)
Réussite de testCommandeDebutStringContexte
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeDefs
\begin{verbatim}
/**
 * TestCommandeDefs.java                              7 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.motscles.CommandeDefs;

/**
 * Tests unitaires de {@link interpreteurlir.motscles.CommandeDefs}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestCommandeDefs {
 
    /** Jeux d'essais de CommandeDefs valides pour les tests */
    private CommandeDefs[] fixture = { 
            new CommandeDefs("", new Contexte()),
            new CommandeDefs("    ", new Contexte()),
            new CommandeDefs("\t", new Contexte()),
    };
    
    /**
     * Tests unitaires de {@link CommandeDefs#CommandeDefs(String, Contexte)}
     */
    public void testCommandeDefsStringContexte() {
        System.out.println("\tExécution du test de CommandeDefs"
                           + "#CommandeDefs(String, Contexte)");
        
        /* Tests Commande invalide */
        String[] arguments = { "$chaine", " a   ", "fin" };
        Contexte contexte = new Contexte();
        for (int numTest = 0 ; numTest < arguments.length ; numTest++) {
            try {
                new CommandeDefs(arguments[numTest], contexte);
                echec();
            } catch (InterpreteurException lancee) { 
            }
        }
        
        try {
            new CommandeDefs("", new Contexte());
            new CommandeDefs("    ", new Contexte());
            new CommandeDefs("\t", new Contexte());
        } catch (InterpreteurException e) {
            echec();
        }
    }
    
    
    /**
     * Tests unitaires de {@link CommandeDefs#executer()}
     */
    public void testExecuter() {
        System.out.println("\tExécution du test de CommandeDefs#executer()");
        for (CommandeDefs cmd : fixture) {
            System.out.println("Affichage du contexte :");
            assertTrue(cmd.executer());
        }
        
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeDefs#CommandeDefs(String, Contexte)
Réussite de testCommandeDefsStringContexte
    Exécution du test de CommandeDefs#executer()
Affichage du contexte :
aucune variable n'est définie
Affichage du contexte :
aucune variable n'est définie
Affichage du contexte :
aucune variable n'est définie
Réussite de testExecuter
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeEfface
\begin{verbatim}
/**
 * TestCommandeEfface.java                                           16 mai 2021
 * IUT info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.CommandeEfface;
import interpreteurlir.motscles.instructions.InstructionAffiche;
import interpreteurlir.programmes.Etiquette;
import interpreteurlir.programmes.Programme;

/**
 * Tests unitaires de la commande d'effacement de lignes de codes pour 
 * l'interpréteur LIR.
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestCommandeEfface {
    
    /** Contexte pour tests */
    public static final Contexte CONTEXTE_TESTS = new Contexte();
    
    /** Programme global pour tests */
    public static final Programme PGM_TESTS = new Programme();
    
    /** Jeu de test valide */
    public static final CommandeEfface[] FIXTURE = {
        new CommandeEfface("1:99999", CONTEXTE_TESTS),
        new CommandeEfface(" 1 : 99999 ", CONTEXTE_TESTS),
        new CommandeEfface("99999 :1 ", CONTEXTE_TESTS),
        new CommandeEfface("1 : 1", CONTEXTE_TESTS),
        new CommandeEfface(" 250: 150 ", CONTEXTE_TESTS)
    };
    
    /** Test du constructeur */
    public static void testCommandeEfface() {
        
        final String[] INVALIDES = {
            "",
            "23 : ",
            " : 15",
            "coucou",
            "50 : coucou",
            "12.4: 24",
            "-14 : 90",
            "\'a\' : 99"
        };
        
        System.out.println("\tExécution du test de CommandeEfface"
                           + "(String, Contexte)");
        for (String aTester : INVALIDES) {
            try {
                new CommandeEfface(aTester, CONTEXTE_TESTS);
                echec();
            } catch (InterpreteurException e) {
               // test OK
            }
        }
    }
    
    /** Test de executer() */
    public static void testExecuter() {
        
        System.out.println("\tExécution du test d'executer()\nTest visuel :");
        Commande.referencerProgramme(PGM_TESTS);
        PGM_TESTS.ajouterLigne(new Etiquette(10), 
                new InstructionAffiche("Bonjour", CONTEXTE_TESTS));
        PGM_TESTS.ajouterLigne(new Etiquette(20), 
                new InstructionAffiche("Comment", CONTEXTE_TESTS));
        PGM_TESTS.ajouterLigne(new Etiquette(30), 
                new InstructionAffiche("Allez", CONTEXTE_TESTS));
        PGM_TESTS.ajouterLigne(new Etiquette(40), 
                new InstructionAffiche("Vous", CONTEXTE_TESTS));
        PGM_TESTS.ajouterLigne(new Etiquette(50), 
                new InstructionAffiche("foobar", CONTEXTE_TESTS));
        System.out.println(PGM_TESTS);
        
        CommandeEfface effacement = new CommandeEfface("20:30", CONTEXTE_TESTS);
        effacement.executer();
        
        System.out.println(PGM_TESTS);
        
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeEfface(String, Contexte)
Réussite de testCommandeEfface
    Exécution du test d'executer()
Test visuel :
10 affiche Bonjour
20 affiche Comment
30 affiche Allez
40 affiche Vous
50 affiche foobar

10 affiche Bonjour
40 affiche Vous
50 affiche foobar

Réussite de testExecuter
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeFin
\begin{verbatim}
/**
 * TestCommandeFin.java                              7 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.motscles.CommandeFin;

/**
 * Tests unitaires de {@link interpreteurlir.motscles.CommandeFin}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestCommandeFin {
    
    /**
     * Tests unitaires de {@link CommandeFin#CommandeFin(String, Contexte)}
     */
    public void testCommandeFinStringContexte() {
        System.out.println("\tExécution du test de CommandeFin"
                           + "#CommandeFin(String, Contexte)");
        
        /* Tests Commande invalide */
        String[] arguments = { "$chaine", " a   ", "fin" };
        Contexte contexte = new Contexte();
        for (int numTest = 0 ; numTest < arguments.length ; numTest++) {
            try {
                new CommandeFin(arguments[numTest], contexte);
                echec();
            } catch (InterpreteurException lancee) { 
            }
        }
        
        try {
            new CommandeFin("", new Contexte());
            new CommandeFin("    ", new Contexte());
            new CommandeFin("\t", new Contexte());
        } catch (InterpreteurException e) {
            echec();
        }
    }
    
    
    /**
     * Tests unitaires de {@link CommandeFin#executer()}
     */
    public void testExecuter() {
        System.out.println("\tExécution du test de CommandeFin#executer()");
        System.out.println("\tLe programme doit s'éteindre en affichant un "
                           + "message d'aurevoir :");
        System.out.println("Test exécuter désactiver");
        //fixture[0].executer();
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeFin#executer()
    Le programme doit s'éteindre en affichant un message d'aurevoir :
Test exécuter désactiver
Réussite de testExecuter
    Exécution du test de CommandeFin#CommandeFin(String, Contexte)
Réussite de testCommandeFinStringContexte
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeLance
\begin{verbatim}
/**
 * TestCommandeLance.java                                        15 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.motscles.tests;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.expressions.Expression;
import interpreteurlir.motscles.CommandeLance;

import static info1.outils.glg.Assertions.*;

import info1.outils.glg.TestException;

/** 
 * Tests unitaires de la classe CommandeLance
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestCommandeLance {
    
    private Contexte contexteTest = new Contexte();
    
    private final CommandeLance[] FIXTURE = {
        new CommandeLance("", contexteTest),
        new CommandeLance("10", contexteTest),
        new CommandeLance("9", contexteTest),
        new CommandeLance("20", contexteTest),
        new CommandeLance("70", contexteTest),
        new CommandeLance("40", contexteTest),
    };
    
    private final String[] ARGS_VALIDES = {
        "",
        "10",
        "9",
        "20",
        "70",
        "40"
    };    

    /** 
     * Test unitaire de 
     * {@link CommandeLance#CommandeLance(String, interpreteurlir.Contexte)}
     */
    public void testCommandeLance() {
        
        final String[] ARGS_INVALIDES = {
            "greuuuuuu",
            " motus 5800",
            "100000",
            "-4",
            "$$$$£££"
        };
        
        Expression.referencerContexte(contexteTest);
        
        System.out.println("\tExécution du test de "
                           + "CommandeLance#CommandeLance(String, Contexte)");
        
        for (int i = 0; i < ARGS_INVALIDES.length; i++) {
            try {
                new CommandeLance(ARGS_INVALIDES[i], contexteTest);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        for (int i = 0 ; i < ARGS_VALIDES.length ; i++) {
            try {
                contexteTest.raz();
                new CommandeLance(ARGS_VALIDES[i], contexteTest);
            } catch (InterpreteurException lancee) {
                echec();
            }
        }
    }
    
    /**
     * Test unitaire de {@link CommandeLance#executer()}
     */
    public void testExecuter() {
        
        //ecrireProgrammeTest();
        Expression.referencerContexte(contexteTest);
        
        System.out.println("\tExécution du test de CommandeLance#executer()");
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            try {
                FIXTURE[i].executer();
                echec();
            } catch (RuntimeException lancee) {
                if (lancee instanceof TestException) {
                    echec();
                }
            }
        }
        
        // Tests valides faits en intégration
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeLance#executer()
Réussite de testExecuter
    Exécution du test de CommandeLance#CommandeLance(String, Contexte)
Réussite de testCommandeLance
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeListe
\begin{verbatim}
/**
 * TestCommandeListe.java                                        15 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.motscles.tests;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.expressions.Expression;
import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.CommandeListe;
import interpreteurlir.motscles.instructions.Instruction;
import interpreteurlir.motscles.instructions.InstructionVar;
import interpreteurlir.programmes.Etiquette;
import interpreteurlir.programmes.Programme;

import static info1.outils.glg.Assertions.*;

import info1.outils.glg.TestException;

/** 
 * Tests unitaires de la classe Commande liste
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestCommandeListe {

    private Programme programmeTest = new Programme();
    private Contexte contexteTest = new Contexte();

    private final CommandeListe[] FIXTURE = {
            new CommandeListe("1:89", contexteTest),
            new CommandeListe("13:30", contexteTest),
            new CommandeListe("17:54", contexteTest),
            new CommandeListe("40:108", contexteTest),
    };
    
    private final String[] ARGS_VALIDES = {
            "1:90",
            "5:45",
            "40:56"
    };
    
    private final Etiquette[] JEU_ETIQUETTES = {
            new Etiquette(1),
            new Etiquette(10),
            new Etiquette(13),
            new Etiquette(25),
            new Etiquette(31),
            new Etiquette(40),
            new Etiquette(78),
            new Etiquette(89)
    };
    
    private final Instruction[] JEU_INSTRUCTIONS = {
            new InstructionVar("$res = \"1 \"", contexteTest),
            new InstructionVar("$res = $res + \"10 \"", contexteTest),
            new InstructionVar("$res = $res + \"13 \"", contexteTest),
            new InstructionVar("$res = $res + \"25 \"", contexteTest),
            new InstructionVar("$res = $res + \"31 \"", contexteTest),
            new InstructionVar("$res = $res + \"40 \"", contexteTest),
            new InstructionVar("$res = $res + \"78 \"", contexteTest),
            new InstructionVar("$res = $res + \"89 \"", contexteTest)
    };
    
    private void ecrireProgrammeTest() {
        for (int i = 0 ; i < JEU_ETIQUETTES.length ; i++) {
            programmeTest.ajouterLigne(JEU_ETIQUETTES[i], 
                                       JEU_INSTRUCTIONS[i]);
        }
    }
    
    /** 
     * Test unitaire de 
     * {@link CommandeListe#CommandeListe(String, interpreteurlir.Contexte)}
     */
    public void testCommandeListe() {
        
        final String[] ARGS_INVALIDES = {
            "agreu",
            "0:0",
            "-4:9",
            "45:-8",
            "78:12",
            "1:",
            ":4",
            "1:100000"
        };
        
        System.out.println("\tExécution du test de "
                + "CommandeListe#CommandeListe(String, Contexte)");
        
        for (int i = 0; i < ARGS_INVALIDES.length; i++) {
            try {
                new CommandeListe(ARGS_INVALIDES[i], contexteTest);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        for (int i = 0 ; i < ARGS_VALIDES.length ; i++) {
            try {
                new CommandeListe(ARGS_VALIDES[i], contexteTest);
            } catch (InterpreteurException lancee) {
                echec();
            }
        }
    }
    
    /** 
     * Test unitaire de {@link CommandeListe#executer()}
     */
    public void testExecuter() {
        
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            try {
                FIXTURE[i].executer();
                echec();
            } catch (RuntimeException lancee) {
                if (lancee instanceof TestException) {
                    echec();
                }
                // Test OK
            }
        }

        ecrireProgrammeTest();
        Commande.referencerProgramme(programmeTest);
        Expression.referencerContexte(contexteTest);
        
        System.out.println("\tExécution du test de "
                           + "CommandeListe#executer()");
        
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            try {
                FIXTURE[i].executer();
            } catch (RuntimeException lancee) {
                echec();
            }
        }
    }
     
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeListe#executer()
1 var $res = "1 "
10 var $res = $res + "10 "
13 var $res = $res + "13 "
25 var $res = $res + "25 "
31 var $res = $res + "31 "
40 var $res = $res + "40 "
78 var $res = $res + "78 "
89 var $res = $res + "89 "
13 var $res = $res + "13 "
25 var $res = $res + "25 "
25 var $res = $res + "25 "
31 var $res = $res + "31 "
40 var $res = $res + "40 "
40 var $res = $res + "40 "
78 var $res = $res + "78 "
89 var $res = $res + "89 "
Réussite de testExecuter
    Exécution du test de CommandeListe#CommandeListe(String, Contexte)
Réussite de testCommandeListe
\end{verbatim}

    \item interpreteurlir.motscles.tests.TestCommandeSauve
\begin{verbatim}
/**
 * TestCommandeSauve.java                              21 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.CommandeSauve;
import interpreteurlir.programmes.Programme;
import interpreteurlir.Contexte;
import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;
import interpreteurlir.tests.ProgrammeDeTest;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;

/**
 * Tests unitaires de {@link CommandeSauve}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestCommandeSauve {
    
    /** contexte pour les tests */
    private Contexte contexte = new Contexte();
    
    /** Programme pour les tests */
    private Programme progGlobal = new Programme();
    
    /** Jeu de donnée de commandeSauve valides pour les tests  */
    private CommandeSauve[] fixture = {
        /* chemin valide */
        new CommandeSauve("monProgramme.lir", contexte),
        new CommandeSauve("programmationLIR\\monProgramme.lir", contexte),
        new CommandeSauve("D:\\testInterpreteurLIR\\test1.lir", contexte),
        new CommandeSauve("  D:\\testInterpreteurLIR\\test2.lir\t", contexte),
        
        /* chemin invalide à l'exécution*/
        new CommandeSauve("\\\\monProgramme.lir", contexte),
        new CommandeSauve("monPro//??!gr<>amme.lir", contexte),
        /* chemin inexistant */
        new CommandeSauve("D:\\testInterpreteurLIR\\dossierNonCree\\test1.lir", 
                          contexte),
        /* lecteur inexistant */
        new CommandeSauve("X:\\testInterpreteurLIR\\test1.lir", contexte),    
    };

    /**
     * Tests unitaires de {@link CommandeSauve#CommandeSauve(String, Contexte)}
     */
    public void testCommandeSauveStringContexte() {
        final String[] ARGS_INVALIDES = {
             "",
             "   \t  ",
             "D:\\utilisateurs\\defaut\\bureau\\",
             "D:\\utilisateurs\\defaut\\bureau\\monProgramme.txt",
             "D:\\utilisateurs\\defaut\\bureau\\monProgramme",
             "nouveau dossier\\monProgramme.java",
             "nouveau dossier\\monProgramme",
             "monProgramme.class",
             "monProgramme"
        };
        
        System.out.println("\tExécution du test de "
                           + "CommandeSauve#CommandeSauve(String, Contexte)");
        
        for (String aTester : ARGS_INVALIDES) {
            try {
                new CommandeSauve(aTester, contexte);
                echec();
            } catch (InterpreteurException e) {
                // test ok
            }
        }
        
        try {
            /* chemin valide */
            new CommandeSauve("monProgramme.lir", contexte);
            new CommandeSauve("programmationLIR\\monProgramme.lir", contexte);
            new CommandeSauve("D:\\testInterpreteurLIR\\test1.lir", contexte);
            new CommandeSauve("  D:\\testInterpreteurLIR\\test2.lir\t",
                              contexte);
            /* chemin invalide à l'exécution*/
            new CommandeSauve("\\\\monProgramme.lir", contexte);
            new CommandeSauve("monPro//??!gr<>amme.lir", contexte);
            /* chemin inexistant */
            new CommandeSauve("D:\\testInterpreteurLIR\\dossierNonCree\\"
                              + "test1.lir", contexte);
            /* lecteur inexistant */
            new CommandeSauve("X:\\testInterpreteurLIR\\test1.lir", contexte);
        } catch (InterpreteurException e) {
            echec();
        }
        
    }
    
    /**
     * Tests unitaires de {@link CommandeSauve#executer()}
     */
    public void testExecuter() {
        final int INDEX_INVALIDES = 4;
        
        Commande.referencerProgramme(progGlobal);
        System.out.println("\tExécution du test de CommandeSauve#executer()");
        
        /* Tests des chemins invalides */
        for (int index = INDEX_INVALIDES ; index < fixture.length ; index++) {
            try {
                fixture[index].executer();
                echec();
            } catch (ExecutionException lancee) {
                // test OK
            }
        }
        

        try {
            assertFalse(fixture[0].executer());
            assertEquivalence(progGlobal.toString(), 
                              lireFichier("monProgramme.lir"));
            assertFalse(fixture[2].executer());
            assertEquivalence(progGlobal.toString(), 
                    lireFichier("D:\\testInterpreteurLIR\\test1.lir"));
            
            ProgrammeDeTest.genererProgramme(progGlobal, contexte);
            
            assertFalse(fixture[1].executer());
            assertEquivalence(progGlobal.toString(), 
                    lireFichier("programmationLIR\\monProgramme.lir"));
            
            assertFalse(fixture[3].executer());
            assertEquivalence(progGlobal.toString(), 
                    lireFichier("D:\\testInterpreteurLIR\\test2.lir"));
            
        } catch (ExecutionException lancee) {
            echec();
        }

    }

    /**
     * Lit un fichier et retourne le contenu entier du fichier
     * @param cheminFichier chemin du fichier à lire
     * @return contenu du fichier
     */
    private static String lireFichier(String cheminFichier) {
        BufferedReader aTester;
          StringBuilder contenu = new StringBuilder("");
          
          aTester = null;
          try {
              aTester = new BufferedReader(
                           new InputStreamReader(
                               new FileInputStream(cheminFichier)));
              String ligneLue;
              do {
                  ligneLue = aTester.readLine();
                  if (ligneLue != null) {
                      contenu.append(ligneLue).append("\n");
                  }
              } while (ligneLue != null);
              aTester.close();
          } catch (Exception e) {
              echec();
          }
          
          return contenu.toString();
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de CommandeSauve#CommandeSauve(String, Contexte)
Réussite de testCommandeSauveStringContexte
    Exécution du test de CommandeSauve#executer()
Réussite de testExecuter
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionAffiche
\begin{verbatim}
/**
 * TestInstructionAffiche.java                                      13 mai 2021
 * IUT info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.instructions.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;
import interpreteurlir.expressions.Expression;
import interpreteurlir.motscles.instructions.InstructionAffiche;


/**
 * Tests unitaires de l'instruction affiche, avec et sans arguments.
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestInstructionAffiche {
    
    /** Contexte d'execution pour jeux de tests */
    private static final Contexte CONTEXTE_GBL = new Contexte();
    
    /** Jeu données valides pour test de InstructionAffiche */
    private static final InstructionAffiche[] FIXTURE = {
        new InstructionAffiche("", CONTEXTE_GBL),
        new InstructionAffiche("   ", CONTEXTE_GBL),
        new InstructionAffiche("\"Hello World !!!\"", CONTEXTE_GBL),
        new InstructionAffiche("3 + 3", CONTEXTE_GBL),
        new InstructionAffiche("marcel", CONTEXTE_GBL),
        new InstructionAffiche("marcel + -3", CONTEXTE_GBL),
        new InstructionAffiche("$fraysse", CONTEXTE_GBL),
        new InstructionAffiche("$sanchis + \"coucou\"", CONTEXTE_GBL),
        new InstructionAffiche("\"300000000000000000 ça passe\"", CONTEXTE_GBL)
    };
    
    /** 
     * Tests unitaires de 
     * {@link InstructionAffiche#InstructionAffiche(String, Contexte)} 
     */
    public static void testInstructionAffiche() {
        
        final String[] INVALIDES = {
            "a = b + c",
            "3 +",
            "une chaine de plus de soixtante quinze caractères ne devrait pas"
            + "pouvoir s'afficher parce qu'elle est trop longue !",
            "30000000000000000000000",
            "12aveyron",
            "$aveyron + 12"
        };
        
        Expression.referencerContexte(CONTEXTE_GBL);
        System.out.println("\tExécution du test de InstructionAffiche(String"
                           + ", Contexte)");
        for (String argInvalide : INVALIDES) {
            try {
                new InstructionAffiche(argInvalide, CONTEXTE_GBL);
                echec();
            } catch (InterpreteurException | ExecutionException lancee) {
                // Empty body
            }
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionAffiche#executer()}
     */
    public static void testExecuter() {
        
        System.out.println("\tExécution du test de executer()\nTEST VISUEL SUR "
                           + "CONSOLE :");
        
        Expression.referencerContexte(CONTEXTE_GBL);
        for (InstructionAffiche aLancer : FIXTURE) {
            System.out.println("\n\ttest visuel suivant : ");
            aLancer.executer(); 
        }
        
        System.out.println();
    }
    
    /**
     * Tests unitaires de {@link InstructionAffiche#toString()}
     */
    public static void testToString() {
        
        final String[] ATTENDUS = {
            "affiche",
            "affiche",
            "affiche \"Hello World !!!\"",
            "affiche 3 + 3",
            "affiche marcel",
            "affiche marcel + -3",
            "affiche $fraysse",
            "affiche $sanchis + \"coucou\"",
            "affiche \"300000000000000000 ça passe\""
        };
        
        System.out.println("\tExécution du test de toString()");
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            assertTrue(FIXTURE[i].toString().compareTo(ATTENDUS[i]) == 0);
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de InstructionAffiche(String, Contexte)
Réussite de testInstructionAffiche
    Exécution du test de executer()
TEST VISUEL SUR CONSOLE :

    test visuel suivant : 


    test visuel suivant : 


    test visuel suivant : 
Hello World !!!
    test visuel suivant : 
6
    test visuel suivant : 
0
    test visuel suivant : 
-3
    test visuel suivant : 

    test visuel suivant : 
coucou
    test visuel suivant : 
300000000000000000 ça passe
Réussite de testExecuter
    Exécution du test de toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionEntre
\begin{verbatim}
/**
 * TestInstructionEntre.java                              13 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.instructions.tests;

import interpreteurlir.motscles.instructions.InstructionEntre;
import interpreteurlir.Contexte;
import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;

import static info1.outils.glg.Assertions.*;
/** 
 * Test unitaire de {@link InstructionEntre}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestInstructionEntre {
    
    /**
     * Contexte pour les tests
     */
    private final Contexte CONTEXTE_GLB = new Contexte();
    
    /**
     * Jeux de données de instructionEntre valides
     */
    private InstructionEntre[] fixture = { 
            new InstructionEntre("$chaine     ", CONTEXTE_GLB),
            new InstructionEntre("     $toto", CONTEXTE_GLB),
            new InstructionEntre("\t  entier  ", CONTEXTE_GLB),
            new InstructionEntre("resultat", CONTEXTE_GLB),
    };

    /** 
     * Test unitaire de 
     * {@link InstructionEntre#InstructionEntre(String, Contexte)}
     */
    public void testInstructionEntreStringContexte() {
        
        System.out.println("\tExécution du test de "
                + "InstructionEntre#InstructionEntre(String, Contexte)");
        
        final Contexte CONTEXTE = new Contexte();
        
        final String[] ARGS_INVALIDES = { 
                "", 
                "$hhjdkeliyehozrbnjkm236khl749k",
                "$chaine = $toto + \"\"",
                "entier/2",
                "45"
        };
        
        
        for (String arg : ARGS_INVALIDES) {
            
            try {
                new InstructionEntre(arg, CONTEXTE);
                echec();
                
            } catch (InterpreteurException lancee) {
            }
            
        }
        
        try {
            new InstructionEntre("$chaine     ", CONTEXTE);
            new InstructionEntre("     $toto", CONTEXTE);
            new InstructionEntre("\t  entier  ", CONTEXTE);
            new InstructionEntre("resultat", CONTEXTE);
        } catch (InterpreteurException lancee) {
            echec();
        }
    }
    
    /**
     * Test unitaire de {@link InstructionEntre#toString()}
     */
    public void testToString() {
        
        final String[] TEXTE_ATTENDU = { 
            "entre $chaine", "entre $toto", "entre entier", "entre resultat"
        };
        
        System.out.println("\tExécution du test de "
                           + "InstructionEntre#toString()");
        
        for (int numTest = 0 ; numTest < TEXTE_ATTENDU.length ; numTest++) {
            assertEquivalence(TEXTE_ATTENDU[numTest],
                              fixture[numTest].toString());
        }
        
        
        
    }
    
    /**
     * Test unitaire de {@link InstructionEntre#executer()}
     */
    public void testExecuter() {
        System.out.println("Execution du test de InstructionEntre#executer()");
        
        for (InstructionEntre entre : fixture) {
            
            System.out.println("? " + entre);
            try {
                assertFalse(entre.executer());
                System.out.println("ok");
            } catch (ExecutionException lancee) {
                System.err.println("nok : " + lancee.getMessage());
            }
        }
        System.out.println("Contexte : \n" + CONTEXTE_GLB);
    }
    
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de InstructionEntre#toString()
Réussite de testToString
Execution du test de InstructionEntre#executer()
? entre $chaine
"uneChaine"
ok
? entre $toto
"uneAutreChaine"
ok
? entre entier
42
ok
? entre resultat
10
ok
Contexte : 
$chaine = ""uneChaine""
$toto = ""uneAutreChaine""
entier = 42
resultat = 10

Réussite de testExecuter
    Exécution du test de InstructionEntre#InstructionEntre(String, Contexte)
Réussite de testInstructionEntreStringContexte
\end{verbatim}


    \item interpreteurlir.motscles.instructions.tests.TestInstructionProcedure
\begin{verbatim}
/**
 * TestInstructionProcedure.java                                        15 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.motscles.instructions.tests;

import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.instructions.InstructionProcedure;
import interpreteurlir.motscles.instructions.InstructionVar;
import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurEntier;
import interpreteurlir.expressions.Expression;
import interpreteurlir.programmes.*;

import static info1.outils.glg.Assertions.*;

import info1.outils.glg.TestException;

/**
 * Tests unitaires de {@link InstructionProcedure}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 *
 */
public class TestInstructionProcedure {
    
    /** Contexte global pour les tests */
    private final Contexte CONTEXTE = new Contexte();
    
    /** Jeu de donnée d'InstructionProcedure valides */
    private final InstructionProcedure[] FIXTURE = {
            new InstructionProcedure("    1    ", CONTEXTE),
            new InstructionProcedure("    10", CONTEXTE),
            new InstructionProcedure("5    ", CONTEXTE),
            new InstructionProcedure("1549", CONTEXTE),
            new InstructionProcedure("99999", CONTEXTE)
    };
    
    /** Programme utilisé dans les tests */
    private final Programme PROG_REFERENCE = new Programme(); 
    
    /**
     * Tests unitaires de
     * {@link InstructionProcedure#InstructionProcedure(String, Contexte)}
     */
    public void testInstructionProcedureStringContexte() {
        
        System.out.println("\tExecution du test de "
                           + "InstructionProcedure"
                           + "#InstructionProcedure(String, Contexte)");
        
        final String[] ARGS_INVALIDES = {
                /* Sans arguments */
                "",
                "\t",
                "      ",
                "\n",
                
                /* Arguments invalides */
                "LETTRE",
                "6messages",
                "-5",
                "100000"
        };
        
        for (int i = 0 ; i < ARGS_INVALIDES.length ; i++) {
            try {
                new InstructionProcedure(ARGS_INVALIDES[i], CONTEXTE);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        try {
            new InstructionProcedure("    1    ", CONTEXTE);
            new InstructionProcedure("    10", CONTEXTE);
            new InstructionProcedure("5    ", CONTEXTE);
            new InstructionProcedure("1549", CONTEXTE);
            new InstructionProcedure("99999", CONTEXTE);
        } catch (InterpreteurException e) {
            echec();
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionProcedure#toString()}
     */
    public void testToString() {
        System.out.println("\tExecution du test de "
                           + "InstructionProcedure#toString()");
        
        final String[] FORMAT_ATTENDU = {
                "procedure 1",
                "procedure 10",
                "procedure 5",
                "procedure 1549",
                "procedure 99999",
        };
        
        for (int i = 0 ; i < FORMAT_ATTENDU.length ; i++) {
            assertEquivalence(FORMAT_ATTENDU[i], FIXTURE[i].toString());
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionProcedure#executer()}
     */
    public void testExecuter() {
        System.out.println("\tExecution du test de "
                           + "InstructionProcedure#executer()");
        
        for(InstructionProcedure instruction : FIXTURE) {
            try {
                instruction.executer();
                echec();
            } catch (RuntimeException e) {
                if (e instanceof TestException) {
                    echec();
                }
                // Test OK
            }
        }
        
        Commande.referencerProgramme(PROG_REFERENCE);
        Expression.referencerContexte(CONTEXTE);
        
        PROG_REFERENCE.ajouterLigne(new Etiquette(3),
                                    new InstructionVar("test=5", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(4), FIXTURE[1]);
        PROG_REFERENCE.ajouterLigne(new Etiquette(5),
                                    new InstructionVar("test=-1", CONTEXTE));
        
        PROG_REFERENCE.lancer();
        assertEquivalence(CONTEXTE.lireValeurVariable(
                          new IdentificateurEntier("test")).getValeur(), 5);
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Execution du test de InstructionProcedure#toString()
Réussite de testToString
    Execution du test de InstructionProcedure#executer()
Réussite de testExecuter
    Execution du test de InstructionProcedure#InstructionProcedure(String, Contexte)
Réussite de testInstructionProcedureStringContexte
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionRetour
\begin{verbatim}
/**
 * TestInstructionRetour.java                                        15 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.motscles.instructions.tests;

import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.instructions.InstructionProcedure;
import interpreteurlir.motscles.instructions.InstructionRetour;
import interpreteurlir.motscles.instructions.InstructionVar;
import interpreteurlir.programmes.Etiquette;
import interpreteurlir.programmes.Programme;
import interpreteurlir.Contexte;
import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.IdentificateurEntier;
import interpreteurlir.expressions.Expression;

import static info1.outils.glg.Assertions.*;

import info1.outils.glg.TestException;

/**
 * Tests unitaires de {@link InstructionRetour}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 *
 */
public class TestInstructionRetour {
    
    /** Contexte global pour les tests */
    private final Contexte CONTEXTE = new Contexte();
    
    /** Programme utilisé dans les tests */
    private final Programme PROG_REFERENCE = new Programme();
    
    /** Jeu de donnée d'InstructionRetour valides */
    private final InstructionRetour[] FIXTURE = {
            new InstructionRetour("", CONTEXTE),
            new InstructionRetour("   ", CONTEXTE),
            new InstructionRetour("\t", CONTEXTE),
            new InstructionRetour("\t   ", CONTEXTE)
    };
    
    /**
     * Tests unitaires de
     * {@link InstructionRetour#InstructionRetour(String, Contexte)}
     */
    public void testInstructionRetourStringContexte() {
        System.out.println("\t Exécution du test de "
                + "InstructionRetour#InstructionRetour(String, Contexte)");
        
        final String[] ARGS_INVALIDES = {
                "    a    ",
                "bonjour bonsoir",
                "513",
                "@!?/",
                "^p65Na@"
        };
        
        for (int i = 0 ; i < ARGS_INVALIDES.length ; i++) {
            try {
                new InstructionRetour(ARGS_INVALIDES[i], CONTEXTE);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        try {
            new InstructionRetour("", CONTEXTE);
            new InstructionRetour("   ", CONTEXTE);
            new InstructionRetour("\t", CONTEXTE);
            new InstructionRetour("\t   ", CONTEXTE);
        } catch (InterpreteurException lancee) {
            echec();
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionRetour#toString()}
     */
    public void testToString() {
        System.out.println("\tExecution du test de "
                           + "InstructionRetour#toString()");
        
        for (int i = 0 ; i < FIXTURE.length ; i++) {
            assertEquivalence("retour", FIXTURE[i].toString());
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionRetour#executer()}
     */
    public void testExecuter() {
        System.out.println("\tExecution du test de "
                           + "InstructionRetour#executer()");
        
        for(InstructionRetour instruction : FIXTURE) {
            try {
                instruction.executer();
                echec();
            } catch (RuntimeException e) {
                if (e instanceof TestException) {
                    echec();
                }
                // Test OK
            }
        }
        
        Commande.referencerProgramme(PROG_REFERENCE);
        Expression.referencerContexte(CONTEXTE);
        
        /* Test retour procedure invalide */
        PROG_REFERENCE.ajouterLigne(new Etiquette(1), FIXTURE[0]);
        PROG_REFERENCE.ajouterLigne(new Etiquette(4),
                                    new InstructionProcedure("1", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(10), FIXTURE[1]);
        
        try {
            PROG_REFERENCE.lancer(new Etiquette(2));
            echec();
        } catch (ExecutionException lancee) {
            // Test OK
        }
        
        PROG_REFERENCE.raz();
        
        /* Tests retour procedure valide */
        PROG_REFERENCE.ajouterLigne(new Etiquette(1),
                                    new InstructionVar("test=5", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(2), FIXTURE[0]);
        PROG_REFERENCE.ajouterLigne(new Etiquette(3),
                                    new InstructionVar("test=-1", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(4),
                                    new InstructionProcedure("1", CONTEXTE));
        
        PROG_REFERENCE.lancer(new Etiquette(3));
        assertEquivalence(CONTEXTE.lireValeurVariable(
                          new IdentificateurEntier("test")).getValeur(), 5);
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
     Exécution du test de InstructionRetour#InstructionRetour(String, Contexte)
Réussite de testInstructionRetourStringContexte
    Execution du test de InstructionRetour#executer()
Réussite de testExecuter
    Execution du test de InstructionRetour#toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionSi
\begin{verbatim}
/**
 * TestInstructionSi.java                              22 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.instructions.tests;

import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.instructions.InstructionSi;
import interpreteurlir.motscles.instructions.InstructionVar;
import interpreteurlir.programmes.*;
import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.donnees.*;
import interpreteurlir.donnees.litteraux.*;
import interpreteurlir.expressions.Expression;

import static info1.outils.glg.Assertions.*;

/**
 * Tests unitaires de {@link InstructionSi}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestInstructionSi {

    /** contexte pour les tests */
    private Contexte contexte = new Contexte();
    
    /** programme pour les tests */
    private Programme prog = new Programme();
    
    /** Jeu de donnée d'instruction si vaen valides pour les tests*/
    private InstructionSi[] fixture = {
        new InstructionSi("45 = 2 vaen 15", contexte),
        new InstructionSi("age >= 130 vaen 1000", contexte),
        new InstructionSi("$prenom <>\"défaut\" vaen 16", contexte),
        new InstructionSi("resultat    < 20 vaen 17", contexte),
        new InstructionSi("resultat < moyenne vaen 18", contexte),
        new InstructionSi("age > 20 vaen   19", contexte),
        new InstructionSi("\"tata\"    = \"tata\"vaen 20", contexte),
        new InstructionSi("\"toto  \" > $toto vaen1502", contexte),
        new InstructionSi("-5 <= 0 vaen 21", contexte),
        new InstructionSi("resultat < 20    vaen 22", contexte),
    };
    
    /**
     * Tests unitaires de {@link InstructionSi#InstructionSi(String, Contexte)}
     */
    public void testInstructionSiStringContexte() {
        final String[] ARGS_INVALIDES = {
            "",
            "   \t",
            " entier < index",
            "vaen 1050",
            "age = 10 vaen",
            " $prenom = \"défaut\" va 10",
            "$prenom <> $nom  goto 45",
            "$prenom <> $nom  vaen dix",
            "$prenom != $nom  vaen 45",
            /* erreur de type */
            "$prenom <> 5 vaen 450",
            "age > \"\" vaen 450",
            "age >= $prenom vaen 450",
            "\"dix\" = 10 vaen 4500",
        };
        
        System.out.println("\tExécution du test de "
                           + "InstructionSi#InstructionSi(String, Contexte)");
        
        for (String aTester : ARGS_INVALIDES) {
            try {
                new InstructionSi(aTester, contexte);
                echec();
            } catch (InterpreteurException lancee) {
                // testok
            }
        }
        
        try {
            new InstructionSi("45 = 2 vaen 15", contexte);
            new InstructionSi("age >= 130 vaen 1000", contexte);
            new InstructionSi("$prenom <>\"défaut\" vaen 15", contexte);
            new InstructionSi("resultat    < 20 vaen 15", contexte);
            new InstructionSi("resultat < moyenne vaen 15", contexte);
            new InstructionSi("age > 20 vaen   15", contexte);
            new InstructionSi("\"tata\"    = \"tata\"vaen 15", contexte);
            new InstructionSi("\"toto  \" > $toto vaen1502", contexte);
            new InstructionSi("-5 <= 0 vaen 15", contexte);
            new InstructionSi("resultat < 20    vaen 15", contexte);
            new InstructionSi("$chaine <= \"vaen 15\"    vaen 15", contexte);
        } catch (InterpreteurException lancee) {
            echec();
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionSi#toString()}    
     */
    public void testToString() {
        final String[] ATTENDU = {
            "si 45 = 2 vaen 15",
            "si age >= 130 vaen 1000",
            "si $prenom <> \"défaut\" vaen 16",
            "si resultat < 20 vaen 17",
            "si resultat < moyenne vaen 18",
            "si age > 20 vaen 19",
            "si \"tata\" = \"tata\" vaen 20",
            "si \"toto  \" > $toto vaen 1502",
            "si -5 <= 0 vaen 21",
            "si resultat < 20 vaen 22",
        };
        System.out.println("\tExécution du test de InstructionSi#toString()");
        
        for (int numTest = 0 ; numTest < ATTENDU.length ; numTest++) {
            assertEquivalence(ATTENDU[numTest], fixture[numTest].toString());
        }
    }
    
    /**
     * Tests unitaires de {@link InstructionSi#executer()}
     */
    public void testExecuter() {
        Commande.referencerProgramme(prog);
        prog.ajouterLigne(new Etiquette(15), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(16), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(17), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(18), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(19), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(20), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(21), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(22), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(1000), 
                new InstructionVar("valeur = valeur -1", contexte));
        prog.ajouterLigne(new Etiquette(1502), 
                new InstructionVar("valeur = valeur -1", contexte));
        Expression.referencerContexte(contexte);

        
        final int[] VALEUR_ATTENDU = {
            0, // pas de saut
            0,
            -9, // saut en 16
            -8, // saut en 17
            0,
            -6, // saut en 19
            -5, // saut en 20
            -1, // saut en 1502
            -4, // saut en 21
            -3, // saut en 22
        };
        
        System.out.println("\tExécution du test de InstructionSi#executer()");
        
        for (int numTest = 0 ; numTest < VALEUR_ATTENDU.length ; numTest++) {
            /* initialisation du contexte */
            contexte.raz();
            contexte.ajouterVariable(new IdentificateurEntier("moyenne"), 
                    new Entier("-2"));
            contexte.ajouterVariable(new IdentificateurEntier("age"), 
                    new Entier("99"));
            contexte.ajouterVariable(new IdentificateurChaine("$toto"), 
                    new Chaine("\"toto\""));
            
            fixture[numTest].executer();
            assertEquivalence(VALEUR_ATTENDU[numTest], 
                              ((Integer)contexte.lireValeurVariable(
                                      new IdentificateurEntier("valeur"))
                                      .getValeur()).intValue());
        } 
    }
    

}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de InstructionSi#toString()
Réussite de testToString
    Exécution du test de InstructionSi#executer()
Réussite de testExecuter
    Exécution du test de InstructionSi#InstructionSi(String, Contexte)
Réussite de testInstructionSiStringContexte
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionStop
\begin{verbatim}
/**
 * TestInstructionStop.java                                             16 mai 2021
 * IUT info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.instructions.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.expressions.Expression;
import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.instructions.InstructionAffiche;
import interpreteurlir.motscles.instructions.InstructionStop;
import interpreteurlir.programmes.Etiquette;
import interpreteurlir.programmes.Programme;

/**
 * Tests unitaires de l'instruction stop de l'interpréteur LIR.
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestInstructionStop {
    
    /** Contexte d'exécution nécessaire à instanciation */
    private static final Contexte CONTEXTE_TESTS = new Contexte();
    
    /** Instruction stop valide */
    public static final InstructionStop[] FIXTURE = {
            new InstructionStop("", CONTEXTE_TESTS),
            new InstructionStop("\t", CONTEXTE_TESTS),
            new InstructionStop(" ", CONTEXTE_TESTS)
    };
    /** Tests du constructeur */
    public static void testInstructionStop() {
        
        final String[] INVALIDES = {
            "coucou",
            " Bonjour",
            null,
            "entier = 2 + 3"
        };
        
        System.out.println("\tExécution du test de InstructionStop"
                           + "(String, Contexte)");
        for (String aTester : INVALIDES) {
            try {
                new InstructionStop(aTester, CONTEXTE_TESTS);
                echec();
            } catch (InterpreteurException | NullPointerException e) {
                // Empty block
            }
        }
    }
    
    /** Test de executer() */
    public static void testExecuter() {
        Programme pgmTest = new Programme();
        System.out.println("\tExécution du test de executer()\nTest Visuels\n");
        Commande.referencerProgramme(pgmTest);
        Expression.referencerContexte(CONTEXTE_TESTS);
        pgmTest.ajouterLigne(new Etiquette(10), 
                new InstructionAffiche("\"Bonjour\"", CONTEXTE_TESTS));
        pgmTest.ajouterLigne(new Etiquette(20), 
                new InstructionAffiche("\"Comment\"", CONTEXTE_TESTS));
        pgmTest.ajouterLigne(new Etiquette(30), 
                new InstructionAffiche("\"Allez\"", CONTEXTE_TESTS));
        pgmTest.ajouterLigne(new Etiquette(40), 
                new InstructionAffiche("\"Vous\"", CONTEXTE_TESTS));
        pgmTest.ajouterLigne(new Etiquette(45), 
                new InstructionStop("", CONTEXTE_TESTS));
        pgmTest.ajouterLigne(new Etiquette(50), 
                new InstructionAffiche("\"foobar\"", CONTEXTE_TESTS));
        System.out.println(pgmTest);
        System.out.println("lancement du programme : ne doit pas "
                           + "afficher foobar");
        pgmTest.lancer();
        
        System.out.println();
    }
    
    /** Tests de toString() */
    public static void testToString() {
        
        final String ATTENDUE = "stop";
        System.out.println("\tExécution du test de toString()");
        for (InstructionStop valide : FIXTURE)
             assertTrue(valide.toString().compareTo(ATTENDUE) == 0);
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de executer()
Test Visuels

10 affiche "Bonjour"
20 affiche "Comment"
30 affiche "Allez"
40 affiche "Vous"
45 stop
50 affiche "foobar"

lancement du programme : ne doit pas afficher foobar
BonjourCommentAllezVous
Réussite de testExecuter
    Exécution du test de toString()
Réussite de testToString
    Exécution du test de InstructionStop(String, Contexte)
Réussite de testInstructionStop
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionVaen
\begin{verbatim}
/**
 * TestInstructionVaen.java                                        15 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.motscles.instructions.tests;

import interpreteurlir.motscles.Commande;
import interpreteurlir.motscles.instructions.InstructionAffiche;
import interpreteurlir.motscles.instructions.InstructionVaen;
import interpreteurlir.programmes.Etiquette;
import interpreteurlir.programmes.Programme;
import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.expressions.Expression;

import static info1.outils.glg.Assertions.*;

import info1.outils.glg.TestException;

/** 
 * Tests unitaires de {@link InstructionVaen}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 *
 */
public class TestInstructionVaen {

    /** Contexte global pour les tests */
    private final Contexte CONTEXTE = new Contexte();

    /** Programme utilisé dans les tests */
    private final Programme PROG_REFERENCE = new Programme();

    /** Jeu de donnée d'InstructionRetour valides */
    private final InstructionVaen[] FIXTURE = {
            new InstructionVaen("10", CONTEXTE),
            new InstructionVaen("9", CONTEXTE),
            new InstructionVaen("20", CONTEXTE),
            new InstructionVaen("70", CONTEXTE),
            new InstructionVaen("40", CONTEXTE),
    };

    /**
     * Tests unitaires de
     * {@link InstructionVaen#InstructionVaen(String, Contexte)}
     */
    public void testInstructionVaenStringContexte() {
        System.out.println("\tExecution du test de "
                + "InstructionVaen#InstructionVaen(String, Contexte)");
        
        final String[] ARGS_INVALIDES = {
                "greuuuuuu",
                " motus 5800",
                "100000",
                "-4",
                "$$$$£££"
        };

        Expression.referencerContexte(CONTEXTE);

        /* Cas invalides */
        for (int i = 0; i < ARGS_INVALIDES.length; i++) {
            try {
                new InstructionVaen(ARGS_INVALIDES[i], CONTEXTE);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        /* Cas Valides */
        try {
            new InstructionVaen("10", CONTEXTE);
            new InstructionVaen("9", CONTEXTE);
            new InstructionVaen("20", CONTEXTE);
            new InstructionVaen("70", CONTEXTE);
            new InstructionVaen("40", CONTEXTE);
        } catch (InterpreteurException lancee) {
            echec();
        }
    }

    /**
     * Tests unitaires de {@link InstructionVaen#toString()}
     */
    public void testToString() {
        System.out.println("\tExecution du test de "
                + "InstructionVaen#toString()");
        
        final String[] FORMAT_ATTENDU = {
                "vaen 10",
                "vaen 9",
                "vaen 20",
                "vaen 70",
                "vaen 40"
        };
        
        for (int i = 0 ; i < FORMAT_ATTENDU.length ; i++) {
            assertEquivalence(FORMAT_ATTENDU[i], FIXTURE[i].toString());
        }
    }

    /**
     * Tests unitaires de {@link InstructionVaen#executer()}
     */
    public void testExecuter() {
        System.out.println("\tExecution du test de "
                + "InstructionVaen#executer()");
        
        /* Cas invalide : où le programme global est vide */
        for(InstructionVaen instruction : FIXTURE) {
            try {
                instruction.executer();
                echec();
            } catch (RuntimeException e) {
                if (e instanceof TestException) {
                    echec();
                }
                // Test OK
            }
        }
        
        /* Cas valide */
        Commande.referencerProgramme(PROG_REFERENCE);
        Expression.referencerContexte(CONTEXTE);
        
        System.out.println("Test visuel : Ne doit pas afficher "
                           + "les étiquettes (25, 31, 40 )");
        /* 1,10,13 -> 78, 89 (saute 25, 31, 40) */
        PROG_REFERENCE.ajouterLigne(new Etiquette(1),
                new InstructionAffiche("\"1 \"", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(10),
                new InstructionAffiche("\"10 \"", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(13),
                new InstructionAffiche("\"13 \"", CONTEXTE));

        PROG_REFERENCE.ajouterLigne(new Etiquette(25),
                new InstructionAffiche("\"25 \"", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(31),
                new InstructionAffiche("\"31 \"", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(40),
                new InstructionAffiche("\"40 \"", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(78),
                new InstructionAffiche("\"78 \"", CONTEXTE));
        PROG_REFERENCE.ajouterLigne(new Etiquette(89),
                new InstructionAffiche("\"89 \"", CONTEXTE));

        PROG_REFERENCE.ajouterLigne(new Etiquette(14),
                new InstructionVaen("78", CONTEXTE));
                
        PROG_REFERENCE.lancer();
        System.out.println();
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Execution du test de InstructionVaen#InstructionVaen(String, Contexte)
Réussite de testInstructionVaenStringContexte
    Execution du test de InstructionVaen#executer()
Test visuel : Ne doit pas afficher les étiquettes (25, 31, 40 )
1 10 13 78 89 
Réussite de testExecuter
    Execution du test de InstructionVaen#toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.motscles.instructions.tests.TestInstructionVar
\begin{verbatim}
/**
 * TestInstructionVar.java                                             9 mai 2021
 * IUT info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.motscles.instructions.tests;

import static info1.outils.glg.Assertions.*;
import interpreteurlir.Contexte;
import interpreteurlir.InterpreteurException;
import interpreteurlir.motscles.instructions.InstructionVar;

/**
 * Tests unitaires de la classe InstructionVar
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestInstructionVar {
    
    /** jeu de données pour tests */
    public static final String[] VALIDES = {
        "$toto = $tata", "entier=2+2", "$coucou = $toto + \"titi\"",
        "anneeNaissance = 1898"
    };

    /**
     * Test unitaire de {@link InstructionVar#InstructionVar(String, Contexte)}
     */
    public static void testInstructionVar() {
        final String[] EXPRESSIONS_INVALIDES = {
            "bonjour", "", "$toto $tata",
        };
        
        System.out.println("\tExécution du test de InstructionVar(String, "
                           + "Contexte)");
        
        for (String aTester : EXPRESSIONS_INVALIDES) {
            try {
                new InstructionVar(aTester, new Contexte());
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
        for (String aTester : VALIDES) {
            try {
                new InstructionVar(aTester, new Contexte());
            } catch (InterpreteurException lancee) {
                echec();
            }
        }
    }
    
    /**
     * Test unitaire de {@link InstructionVar#toString()}
     */
    public static void testToString() {
        final String[] CHAINES_ATTENDUES = {
                "var $toto = $tata", 
                "var entier = 2 + 2", 
                "var $coucou = $toto + \"titi\"", 
                "var anneeNaissance = 1898"
        };
        
        System.out.println("\tExécution du tes de toString()");
        for (int i = 0 ; i < VALIDES.length ; i++) {
            InstructionVar aTester = new InstructionVar(VALIDES[i], 
                                                        new Contexte());
            assertTrue(CHAINES_ATTENDUES[i].equals(aTester.toString()));
        }
    }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de InstructionVar(String, Contexte)
Réussite de testInstructionVar
    Exécution du tes de toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.programmes.tests.TestEtiquette
\begin{verbatim}
/**
 * TestEtiquette.java                              13 mai 2021
 * IUT Rodez info1 2020-2021, pas de copyright, aucun droit
 */
package interpreteurlir.programmes.tests;

import static info1.outils.glg.Assertions.*;

import interpreteurlir.InterpreteurException;
import interpreteurlir.programmes.Etiquette;

/**
 * Tests unitaires de {@link Etiquette}
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heïa Dexter
 * @author Lucas Vabre
 */
public class TestEtiquette {

    /** Jeu de données valides pour les tests */
    private Etiquette[] fixture = {
            new Etiquette(Etiquette.VALEUR_ETIQUETTE_MIN),
            new Etiquette(10),
            new Etiquette(15),
            new Etiquette(8),
            new Etiquette(18),
            new Etiquette(1500),
            new Etiquette(1501),
            new Etiquette(Etiquette.VALEUR_ETIQUETTE_MAX),
            new Etiquette("" +Etiquette.VALEUR_ETIQUETTE_MIN),
            new Etiquette("   10"),
            new Etiquette("15 "),
            new Etiquette("8"),
            new Etiquette("18"),
            new Etiquette("1500  "),
            new Etiquette("  1501   "),
            new Etiquette("" + Etiquette.VALEUR_ETIQUETTE_MAX),
    };
    
    /**
     * Tests unitaires de {@link Etiquette#Etiquette(int)}
     */
    public void testEtiquetteInt() {
        System.out.println("\tExécution du test de Etiquette#Etiquette(int)");
        
        final int[] INVALIDES = {
                Integer.MIN_VALUE, -1, 0, 100000, Integer.MAX_VALUE
        };
        
        for (int valeur : INVALIDES) {
            try {
                new Etiquette(valeur);
                echec();
            } catch (InterpreteurException lancee) {
                
            }
        }
        
        try {
            new Etiquette(Etiquette.VALEUR_ETIQUETTE_MIN);
            new Etiquette(10);
            new Etiquette(15);
            new Etiquette(8);
            new Etiquette(18);
            new Etiquette(1500);
            new Etiquette(1501);
            new Etiquette(Etiquette.VALEUR_ETIQUETTE_MAX);
        } catch (InterpreteurException lancee) {
            echec();
        }
    }
    
    /**
     * Tests unitaires de {@link Etiquette#Etiquette(String)}
     */
    public void testEtiquetteString() {
        System.out.println("\tExécution du test de "
                           + "Etiquette#Etiquette(String)");
        
        final String[] INVALIDES = {
                null, "", "cinq",
                "" + Integer.MIN_VALUE, "-1", "   0",
                "100000   ", "" + Integer.MAX_VALUE
        };
        
        for (String valeur : INVALIDES) {
            try {
                new Etiquette(valeur);
                echec();
            } catch (InterpreteurException lancee) {
                
            }
        }
        
        try {
            new Etiquette("" +Etiquette.VALEUR_ETIQUETTE_MIN);
            new Etiquette("   10");
            new Etiquette("15 ");
            new Etiquette("8");
            new Etiquette("18");
            new Etiquette("1500  ");
            new Etiquette("  1501   ");
            new Etiquette("" + Etiquette.VALEUR_ETIQUETTE_MAX);
        } catch (InterpreteurException lancee) {
            echec();
        }
    }
    
    /**
     * Tests unitaires de {@link Etiquette#toString()}
     */
    public void testToString() {
        System.out.println("\tExécution du test de Etiquette#toString()");
        
        final String[] TEXTE_ATTENDU = {
                "1",
                "10",
                "15",
                "8",
                "18",
                "1500",
                "1501",
                "99999",
                "1",
                "10",
                "15",
                "8",
                "18",
                "1500",
                "1501",
                "99999",
        };
        
        for (int numTest = 0 ; numTest < TEXTE_ATTENDU.length ; numTest++) {
            assertEquivalence(fixture[numTest].toString(), 
                              TEXTE_ATTENDU[numTest]);
        }
    }
    
    /**
     * Tests unitaires de {@link Etiquette#getValeur()}
     */
    public void testGetValeur() {
        System.out.println("\tExécution du test de Etiquette#getValeur()");
        
        final int[] VALEUR_ATTENDUE = {
                1,
                10,
                15,
                8,
                18,
                1500,
                1501,
                99999,
                1,
                10,
                15,
                8,
                18,
                1500,
                1501,
                99999,        
        };
        
        for (int numTest = 0 ; numTest < VALEUR_ATTENDUE.length ; numTest++) {
            assertEquivalence(fixture[numTest].getValeur(), 
                              VALEUR_ATTENDUE[numTest]);
        }
    }
    
    /**
     * Test unitaires de {@link Etiquette#compareTo(Etiquette)}
     */
    public void testCompareTo() {
        final Etiquette[] CROISSANTS = {
                new Etiquette(Etiquette.VALEUR_ETIQUETTE_MIN),
                new Etiquette(8),
                new Etiquette(10),
                new Etiquette(15),
                new Etiquette(18),
                new Etiquette(1500),
                new Etiquette(1501),
                new Etiquette(Etiquette.VALEUR_ETIQUETTE_MAX),        
        };
        
        System.out.println("\tExécution du test de "
                           + "Etiquette#compareTo(Etiquette)");
        
        /** Test croissant */
        for (int reference = 0 ; reference < CROISSANTS.length ; reference++) {
            for (int numtest = reference + 1 ; 
                    numtest < CROISSANTS.length ; 
                    numtest++) {
                assertTrue(CROISSANTS[reference].compareTo(
                                                 CROISSANTS[numtest]) < 0);
            }
        }
        
        /** Test décroissant */
        for (int reference = CROISSANTS.length - 1 ; 
                reference > 0 ; 
                reference--) {
            
            for (int numtest = reference - 1 ; 
                    numtest >= 0 ; 
                    numtest--) {
                assertTrue(CROISSANTS[reference].compareTo(
                                                 CROISSANTS[numtest]) > 0);
            }
        }
        
        Etiquette referenceEgalite = new Etiquette(666);
        assertTrue(referenceEgalite.compareTo(referenceEgalite) == 0);
        assertTrue(referenceEgalite.compareTo(new Etiquette("666")) == 0);
    }

}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de Etiquette#Etiquette(int)
Réussite de testEtiquetteInt
    Exécution du test de Etiquette#Etiquette(String)
Réussite de testEtiquetteString
    Exécution du test de Etiquette#getValeur()
Réussite de testGetValeur
    Exécution du test de Etiquette#compareTo(Etiquette)
Réussite de testCompareTo
    Exécution du test de Etiquette#toString()
Réussite de testToString
\end{verbatim}

    \item interpreteurlir.programmes.tests.TestProgramme
\begin{verbatim}
/**
 * TestProgramme.java                                        14 mai 2021
 * IUT-Rodez info1 2020-2021, pas de droits, pas de copyrights
 */
package interpreteurlir.programmes.tests;

import interpreteurlir.programmes.*;
import interpreteurlir.Contexte;
import interpreteurlir.ExecutionException;
import interpreteurlir.InterpreteurException;
import interpreteurlir.expressions.Expression;
import interpreteurlir.motscles.instructions.*;
import interpreteurlir.motscles.instructions.tests.TestInstructionStop;
import interpreteurlir.motscles.instructions.tests.TestInstructionVaen;

import static info1.outils.glg.Assertions.*;

/** 
 * Tests unitaires de {@link Programme}
 * 
 * @author Nicolas Caminade
 * @author Sylvan Courtiol
 * @author Pierre Debas
 * @author Heia Dexter
 * @author Lucas Vabre
 */
public class TestProgramme {
    
    private Programme programmeTest = new Programme();

    private Contexte contexteTest = new Contexte();
    
    private final Etiquette[] JEU_ETIQUETTES = {
        new Etiquette(1),
        new Etiquette(10),
        new Etiquette(13),
        new Etiquette(5),
        new Etiquette(31),
        new Etiquette(40),
        new Etiquette(5),
        new Etiquette(89)
    };
    
    private final Instruction[] JEU_INSTRUCTIONS = {
        new InstructionVar("$toto = \"toto\"", contexteTest),
        new InstructionVar("tata = 0 + 0", contexteTest),
        new InstructionVar("$titi = \"titi\"", contexteTest),
        new InstructionEntre("agreu", contexteTest),
        new InstructionEntre("tutu", contexteTest),
        new InstructionVar("entier = 93", contexteTest),
        new InstructionVar("$agreuagreu = \"agreu\"", contexteTest),
        new InstructionVar("$youpi = \"youpi lapin\"", contexteTest)
    };
    
    private static final Etiquette[][] BORNES = {
            { new Etiquette(6), new Etiquette(6) },
            { new Etiquette(1), new Etiquette(90) },
            { new Etiquette(31), new Etiquette(39) },
            { new Etiquette(9), new Etiquette(41) }
    };
    
    private static final int DEBUT = 0;
    private static final int   FIN = 1;
    
    private void ajoutLigne() {
        for (int i = 0; i < JEU_ETIQUETTES.length; i++) {
            programmeTest.ajouterLigne(JEU_ETIQUETTES[i], JEU_INSTRUCTIONS[i]);
        }
    }

    /** 
     * Test unitaire de {@link Programme#Programme()} 
     */
    public void testProgramme() {
        System.out.println("\tExécution du test de Programme() : ");
        
        try {
            new Programme();
        } catch (Exception lancee) {
            echec();
        }
    }

    /** 
     * Test unitaire de {@link Programme#ajouterLigne(Etiquette, Instruction)} 
     */
    public void testAjouterLigne() {
        
        final Etiquette[] ETIQUETTES_INVALIDES = {
            null,
            new Etiquette(1),
            null,
        };

        final Instruction[] INSTRUCTIONS_INVALIDES = {
                new InstructionEntre("janis", contexteTest),
                null,
                null
        };
        
        System.out.println("\tExécution du test de ajouterLigne() : ");
        
        for (int i = 0; i < ETIQUETTES_INVALIDES.length; i++) {
            try {
                programmeTest.ajouterLigne(ETIQUETTES_INVALIDES[i], 
                                           INSTRUCTIONS_INVALIDES[i]);
                echec();
            } catch (NullPointerException lancee) {
                // Test OK
            }
        }
        
        for (int i = 0; i < JEU_ETIQUETTES.length; i++) {
            try {
                programmeTest.ajouterLigne(JEU_ETIQUETTES[i], 
                                           JEU_INSTRUCTIONS[i]);
            } catch (NullPointerException lancee) {
                echec();
            }
        }
    }
    
    /** 
     * Test unitaire de {@link Programme#toString()}
     */
    public void testToString() {
        
        final String TEXTE_ATTENDU = "1 var $toto = \"toto\"\n"
                                     + "5 var $agreuagreu = \"agreu\"\n"
                                     + "10 var tata = 0 + 0\n"
                                     + "13 var $titi = \"titi\"\n"
                                     + "31 entre tutu\n"
                                     + "40 var entier = 93\n"
                                     + "89 var $youpi = \"youpi lapin\"\n";
                
        ajoutLigne();
        System.out.println("\tExécution du test de toString() : ");
        assertEquivalence(TEXTE_ATTENDU, programmeTest.toString());
    }
    
    /** 
     * Test unitaire de {@link Programme#raz()}
     */
    public void testRaz() {
        
        System.out.println("\tExécution du test de raz() : ");
        
        programmeTest.raz();
        assertEquivalence(programmeTest.toString(), "");
        
        ajoutLigne();
        programmeTest.raz();
        assertEquivalence(programmeTest.toString(), "");
    }
   
    /** 
     * Test unitaire de {@link Programme#listeBornee(Etiquette, Etiquette)}
     */
    public void testListeBornee() {
        
        final String[] TEXTES_ATTENDUS = {
            "aucune ligne à afficher\n",
            "1 var $toto = \"toto\"\n"
                    + "5 var $agreuagreu = \"agreu\"\n"
                    + "10 var tata = 0 + 0\n"
                    + "13 var $titi = \"titi\"\n"
                    + "31 entre tutu\n"
                    + "40 var entier = 93\n"
                    + "89 var $youpi = \"youpi lapin\"\n",
           "31 entre tutu\n",
           "10 var tata = 0 + 0\n"
                   + "13 var $titi = \"titi\"\n"
                   + "31 entre tutu\n"
                   + "40 var entier = 93\n",
        };
        
        final Etiquette[][] BORNES_INVALIDES = {
                { new Etiquette(8), new Etiquette(6) },
                { new Etiquette(10000), new Etiquette(90) }
        };
        
        ajoutLigne();
        
        System.out.println("\tExécution du test de listeBornee() : ");
        
        for (int i = 0; i < TEXTES_ATTENDUS.length; i++) {
            assertEquivalence(TEXTES_ATTENDUS[i], 
                              programmeTest.listeBornee(BORNES[i][DEBUT], 
                                                        BORNES[i][FIN]));
        }
        
        for (int i = 0; i < BORNES_INVALIDES.length; i++) {
            try {
                programmeTest.listeBornee(BORNES_INVALIDES[i][DEBUT], 
                                          BORNES_INVALIDES[i][FIN]);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
    }
    
    /** 
     * Test unitaire de {@link Programme#effacer(Etiquette, Etiquette)}
     */
    public void testEffacer() {
        
        final String[] TEXTES_ATTENDUS = {
            "1 var $toto = \"toto\"\n"
                    + "5 var $agreuagreu = \"agreu\"\n"
                    + "10 var tata = 0 + 0\n"
                    + "13 var $titi = \"titi\"\n"
                    + "31 entre tutu\n"
                    + "40 var entier = 93\n"
                    + "89 var $youpi = \"youpi lapin\"\n",
            "",
            "1 var $toto = \"toto\"\n"
                    + "5 var $agreuagreu = \"agreu\"\n"
                    + "10 var tata = 0 + 0\n"
                    + "13 var $titi = \"titi\"\n"
                    + "40 var entier = 93\n"
                    + "89 var $youpi = \"youpi lapin\"\n",
            "1 var $toto = \"toto\"\n"
                    + "5 var $agreuagreu = \"agreu\"\n"
                    + "89 var $youpi = \"youpi lapin\"\n",
        };
        
        final Etiquette[][] BORNES_INVALIDES = {
                { new Etiquette(8), new Etiquette(6) },
                { new Etiquette(10000), new Etiquette(90) }
        };
        
        System.out.println("\tExécution du test de effacer() : ");
        
        for (int i = 0; i < BORNES.length ; i++) {
            ajoutLigne();
            programmeTest.effacer(BORNES[i][DEBUT], BORNES[i][FIN]);
            assertEquivalence(programmeTest.toString(), TEXTES_ATTENDUS[i]);
        }
        
        for (int i = 0; i < BORNES_INVALIDES.length; i++) {
            try {
                programmeTest.effacer(BORNES_INVALIDES[i][DEBUT], 
                                          BORNES_INVALIDES[i][FIN]);
                echec();
            } catch (InterpreteurException lancee) {
                // Test OK
            }
        }
        
    }
    
    /** 
     * Test unitaire de {@link Programme#stop()}
     * @see TestInstructionStop#testExecuter()
     */
    public void testStop() {
        System.out.println("\tExécution du test de Programme#stop() "
                + ": voir TestInstructionStop#testExecuter()");
    }
    
    /** 
     * Test unitaire de {@link Programme#lancer(Etiquette)}
     */
    public void testLancerEtiquette() {
        final Etiquette[] ETIQUETTES_DEPART = {
            new Etiquette(1),
            new Etiquette(10),
            new Etiquette(25),
            new Etiquette(90)
        };
        
        Expression.referencerContexte(contexteTest);
        
        ajoutLigne();
        
        System.out.println("\tExécution du test de lancer(Etiquette) "
                           + "TEST INTERACTIF : ");

        for (int i = 0; i < ETIQUETTES_DEPART.length; i++) {
            System.out.println(programmeTest.listeBornee(ETIQUETTES_DEPART[i], 
                                                         new Etiquette(9999)));

            contexteTest.raz();
            programmeTest.lancer(ETIQUETTES_DEPART[i]);
            System.out.println(contexteTest.toString());
        }
    }
    
    /** 
     * Test unitaire de {@link Programme#lancer()}
     */
    public void testLancer() {
        Expression.referencerContexte(contexteTest);
        contexteTest.raz();
        
        ajoutLigne();
        
        System.out.println("\tExécution du test de lancer() "
                + "TEST INTERACTIF : ");
        System.out.println(programmeTest.toString());
        programmeTest.lancer();
        System.out.println(contexteTest.toString());
    }
    
    /** 
     * Test unitaire de {@link Programme#appelProcedure(Etiquette)}
     */
    public void testAppelProcedure() {
        
        System.out.println("\tExécution du test de appelProcedure(Etiquette) "
                           + ": ");
        
        /* Cas Valides */
        try {
            /* Simulation du lancement du programme */
            programmeTest.appelProcedure(new Etiquette(1));
            /* Lancement de 2 procédures */
            programmeTest.appelProcedure(new Etiquette(100));
            programmeTest.appelProcedure(new Etiquette(50));
        } catch (InterpreteurException lancee) {
            echec();
        }
        
        /* Cas Invalides */
        try {
            /* Simulation du lancement du programme */
            programmeTest.appelProcedure(new Etiquette(1));
            
            /* Lancement de 2 procédures */
            programmeTest.appelProcedure(new Etiquette(-30));
            programmeTest.appelProcedure(new Etiquette(10000000));
            echec();
        } catch (InterpreteurException lancee) {
            /* Test OK */
        }
    }
    
   /**
    * Test unitaire de {@link Programme#retourProcedure()}
    */
   public void testRetourProcedure() {
       
       System.out.println("\tExécution du test de retourProcedure() : ");

       // Simulation du lancement du programme
       programmeTest.appelProcedure(new Etiquette(1));
       // Lancement de 2 procédures
       programmeTest.appelProcedure(new Etiquette(100));
       programmeTest.appelProcedure(new Etiquette(50));

       try {
           programmeTest.retourProcedure();
           programmeTest.retourProcedure();
       } catch (ExecutionException lancee) {
           echec();
       }

       try {
           programmeTest.retourProcedure();
           echec();
       } catch (ExecutionException lancee) {
           // Test OK
       }
   }
   
   /** 
    * Test unitaire de {@link Programme#vaen(Etiquette)}
    * @see TestInstructionVaen#testExecuter()
    */
   public void testVaen() {
       System.out.println("\tExécution du test de vaen(Etiquette) "
                          + ": voir TestInstructionVaen#testExecuter()");
      
   }
}
\end{verbatim}
Resultat:
\begin{verbatim}
    Exécution du test de Programme() : 
Réussite de testProgramme
    Exécution du test de toString() : 
Réussite de testToString
    Exécution du test de raz() : 
Réussite de testRaz
    Exécution du test de ajouterLigne() : 
Réussite de testAjouterLigne
    Exécution du test de listeBornee() : 
Réussite de testListeBornee
    Exécution du test de appelProcedure(Etiquette) : 
Réussite de testAppelProcedure
    Exécution du test de vaen(Etiquette) : voir TestInstructionVaen#testExecuter()
Réussite de testVaen
    Exécution du test de Programme#stop() : voir TestInstructionStop#testExecuter()
Réussite de testStop
    Exécution du test de lancer() TEST INTERACTIF : 
1 var $toto = "toto"
5 var $agreuagreu = "agreu"
10 var tata = 0 + 0
13 var $titi = "titi"
31 entre tutu
40 var entier = 93
89 var $youpi = "youpi lapin"

80
$agreuagreu = "agreu"
$titi = "titi"
$toto = "toto"
$youpi = "youpi lapin"
entier = 93
tata = 0
tutu = 80

Réussite de testLancer
    Exécution du test de effacer() : 
Réussite de testEffacer
    Exécution du test de retourProcedure() : 
Réussite de testRetourProcedure
    Exécution du test de lancer(Etiquette) TEST INTERACTIF : 
1 var $toto = "toto"
5 var $agreuagreu = "agreu"
10 var tata = 0 + 0
13 var $titi = "titi"
31 entre tutu
40 var entier = 93
89 var $youpi = "youpi lapin"

5
tutu = 5

10 var tata = 0 + 0
13 var $titi = "titi"
31 entre tutu
40 var entier = 93
89 var $youpi = "youpi lapin"

9
tutu = 9

31 entre tutu
40 var entier = 93
89 var $youpi = "youpi lapin"

10
tutu = 10

aucune ligne à afficher

aucune variable n'est définie

Réussite de testLancerEtiquette
\end{verbatim}
\end{enum}
